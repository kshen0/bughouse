// Generated by CoffeeScript 1.6.3
(function() {
  var A, B, C, COLORS, D, E, F, G, H, board, boardSquares, calculateThreat, canvas, createBoard, createRectangle, dragLock, drawPieces, endSquare, init, isObstructed, moveSuccess, playerColor, resetBoardColor, sendMove, serverBaseUrl, sessionId, setSquareColorForImg, socket, squareSize, startSquare, startX, startY, toggleTurn, whitesTurn;

  window.Game = window.Game || {};

  squareSize = 70;

  COLORS = {
    red: "#e74c3c",
    dark: "#34495e",
    light: "#95a5a6"
  };

  A = 7;

  B = 6;

  C = 5;

  D = 4;

  E = 3;

  F = 2;

  G = 1;

  H = 0;

  startSquare = void 0;

  startX = void 0;

  startY = void 0;

  endSquare = void 0;

  dragLock = false;

  canvas = void 0;

  boardSquares = [];

  board = void 0;

  playerColor = void 0;

  whitesTurn = true;

  serverBaseUrl = document.domain;

  socket = io.connect(serverBaseUrl);

  sessionId = '';

  oCanvas.domReady(function() {
    init();
    canvas = oCanvas.create({
      canvas: "#board",
      background: COLORS.dark
    });
    canvas.height = 8 * squareSize;
    canvas.width = 8 * squareSize;
    board = createBoard(canvas);
    return drawPieces(canvas, board);
  });

  init = function() {
    socket.on('connect', function() {
      sessionId = socket.socket.sessionid;
      console.log("sessionId " + sessionId);
      socket.emit('newUser', {
        id: sessionId,
        name: "player"
      });
      return $.get("/game/playercolor/" + sessionId, function(resp) {
        playerColor = resp;
        return console.log("player color is " + playerColor);
      });
    });
    return socket.on('newMove', function(moveInfo) {
      var end, start;
      if (moveInfo.player === sessionId) {
        return;
      }
      console.log("moveInfo");
      console.log(moveInfo);
      start = moveInfo.startSquare;
      end = moveInfo.endSquare;
      console.log("new incoming move " + moveInfo.piece + " " + start + "-" + end);
      startSquare = board[start[0]][start[1]];
      endSquare = board[end[0]][end[1]];
      return moveSuccess(startSquare.piece.displayObject, startSquare, endSquare);
    });
    /*
    socket.on 'newConnection', (data) ->
      console.log "new connection"
    */

  };

  createBoard = function(canvas) {
    var letter, letters, num, x, y, _i, _j, _k, _l;
    letters = (function() {
      var _i, _results;
      _results = [];
      for (letter = _i = 72; _i >= 65; letter = --_i) {
        _results.push(String.fromCharCode(letter));
      }
      return _results;
    })();
    board = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = letters.length; _i < _len; _i++) {
        letter = letters[_i];
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (num = _j = 1; _j <= 8; num = ++_j) {
            _results1.push(new window.Square("" + letter + num, num, letter));
          }
          return _results1;
        })());
      }
      return _results;
    })();
    for (y = _i = 0; _i <= 7; y = ++_i) {
      for (x = _j = 0; _j <= 7; x = ++_j) {
        board[x][y].x = x;
        board[x][y].y = y;
      }
    }
    /*
    for col in [0..7]
      board[col][1].piece = new window.Pawn("white", "pawn")
      board[col][6].piece = new window.Pawn("black", "pawn")
    
    # Rooks
    board[A][0].piece = new window.Rook("white", "rook")
    board[H][0].piece = new window.Rook("white", "rook")
    board[A][7].piece = new window.Rook("black", "rook")
    board[H][7].piece = new window.Rook("black", "rook")
    
    # Knights 
    board[B][0].piece = new window.Knight("white", "knight")
    board[G][0].piece = new window.Knight("white", "knight")
    board[B][7].piece = new window.Knight("black", "knight")
    board[G][7].piece = new window.Knight("black", "knight")
    */

    board[C][0].piece = new window.Bishop("white", "bishop");
    board[F][0].piece = new window.Bishop("white", "bishop");
    board[C][7].piece = new window.Bishop("black", "bishop");
    board[F][7].piece = new window.Bishop("black", "bishop");
    /*
    
    # Kings
    board[E][0].piece = new window.King("white", "king")
    board[E][7].piece = new window.King("black", "king")
    
    # Queens 
    board[D][0].piece = new window.Queen("white", "queen")
    board[D][7].piece = new window.Queen("black", "queen")
    */

    for (x = _k = 0; _k <= 7; x = ++_k) {
      for (y = _l = 0; _l <= 7; y = ++_l) {
        board[x][y].graphic = createRectangle(x * squareSize, y * squareSize, (y + x) % 2 === 0 ? COLORS.light : COLORS.dark);
      }
    }
    return board;
  };

  createRectangle = function(x, y, color) {
    var rectangle;
    rectangle = canvas.display.rectangle({
      x: x,
      y: y,
      width: squareSize,
      height: squareSize,
      fill: color
    });
    canvas.addChild(rectangle);
    return rectangle;
  };

  drawPieces = function(canvas, board) {
    var img, x, y, _i, _results;
    _results = [];
    for (x = _i = 0; _i <= 7; x = ++_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (y = _j = 0; _j <= 7; y = ++_j) {
          if (board[x][y].piece != null) {
            img = canvas.display.image({
              x: x * squareSize + squareSize / 2,
              y: y * squareSize + squareSize / 2,
              origin: {
                x: "center",
                y: "center"
              },
              image: board[x][y].piece.graphic
            });
            board[x][y].piece.displayObject = img;
            canvas.addChild(img);
            img.bind("mouseenter", function() {
              if (dragLock) {
                return void 0;
              }
              setSquareColorForImg(this, COLORS.red);
              return canvas.redraw();
            });
            img.bind("mouseleave", function() {
              if (dragLock) {
                return void 0;
              }
              setSquareColorForImg(this);
              return canvas.redraw();
            });
            _results1.push(img.dragAndDrop({
              start: function() {
                var draggLock;
                draggLock = true;
                resetBoardColor();
                startX = this.x;
                startY = this.y;
                return startSquare = board[Math.floor(this.x / squareSize)][Math.floor(this.y / squareSize)];
              },
              end: function() {
                var piece, revert, that;
                piece = startSquare.piece;
                if (piece == null) {
                  console.log("No piece selected");
                  return;
                }
                that = this;
                revert = function() {
                  that.x = startX;
                  return that.y = startY;
                };
                if (piece.color !== playerColor) {
                  console.log("Player is " + playerColor + ". Can't move " + piece.color + " piece.");
                  revert();
                  return;
                }
                if ((playerColor === 'white' && !whitesTurn) || (playerColor === 'black' && whitesTurn)) {
                  console.log("" + playerColor + " cannot move out of turn");
                  revert();
                  return;
                }
                endSquare = board[Math.floor(this.x / squareSize)][Math.floor(this.y / squareSize)];
                return piece.move(startSquare, endSquare, function(isValid) {
                  if (!isValid || isObstructed(startSquare, endSquare, board)) {
                    return revert();
                  } else {
                    return moveSuccess(that, startSquare, endSquare, true);
                  }
                });
              }
            }));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  resetBoardColor = function() {
    var x, y, _i, _results;
    _results = [];
    for (y = _i = 0; _i <= 7; y = ++_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (x = _j = 0; _j <= 7; x = ++_j) {
          if ((y + x) % 2 === 0) {
            _results1.push(board[x][y].graphic.fill = COLORS.light);
          } else {
            _results1.push(board[x][y].graphic.fill = COLORS.dark);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  setSquareColorForImg = function(img, color) {
    var piece, sq, square, threatenedSqs, x, y, _i, _len, _results;
    x = Math.floor(img.x / squareSize);
    y = Math.floor(img.y / squareSize);
    square = board[x][y];
    piece = square.piece;
    if (piece == null) {
      return;
    }
    threatenedSqs = piece.getThreatenedSquares(board, x, y);
    /*
    for sq in threatenedSqs
      if not color?
        console.log "#{sq.x}, #{sq.y}"
        if (sq.y + sq.x) % 2 == 0
          color = COLORS.light
        else
          color = COLORS.dark
      sq.graphic.fill = color
    */

    _results = [];
    for (_i = 0, _len = threatenedSqs.length; _i < _len; _i++) {
      sq = threatenedSqs[_i];
      _results.push(sq.graphic.fill = color || ((sq.y + sq.x) % 2 === 0 ? COLORS.light : COLORS.dark));
    }
    return _results;
  };

  moveSuccess = function(displayObj, startSquare, endSquare, movedBySelf) {
    if (displayObj == null) {
      console.log("invalid displayObj: " + displayObj);
      return;
    }
    if (movedBySelf) {
      sendMove(startSquare, endSquare);
    }
    console.log("" + startSquare.piece.text + " " + startSquare.name + "-" + endSquare.name);
    if (endSquare.piece != null) {
      endSquare.piece.displayObject.remove();
    }
    startSquare.piece.square = endSquare;
    endSquare.piece = startSquare.piece;
    startSquare.piece = void 0;
    displayObj.x = (endSquare.x * squareSize) + squareSize / 2;
    displayObj.y = (endSquare.y * squareSize) + squareSize / 2;
    /*
    displayObj.x = (displayObj.x - displayObj.x % squareSize) + squareSize / 2
    displayObj.y = (displayObj.y - displayObj.y % squareSize) + squareSize / 2
    */

    toggleTurn();
    dragLock = false;
    return canvas.redraw();
  };

  toggleTurn = function() {
    whitesTurn = !whitesTurn;
    if (whitesTurn) {
      return $('#turn-label').text("White's turn");
    } else {
      return $('#turn-label').text("Black's turn");
    }
  };

  calculateThreat = function() {
    var piece, sq, threatenedSquares, x, y, _i, _j, _k, _results;
    for (x = _i = 0; _i <= 7; x = ++_i) {
      for (y = _j = 0; _j <= 7; y = ++_j) {
        board[x][y].threats = [];
      }
    }
    _results = [];
    for (x = _k = 0; _k <= 7; x = ++_k) {
      _results.push((function() {
        var _l, _results1;
        _results1 = [];
        for (y = _l = 0; _l <= 7; y = ++_l) {
          piece = board[x][y].piece;
          if (piece != null) {
            threatenedSquares = piece.getThreatenedSquares(board);
            _results1.push((function() {
              var _len, _m, _results2;
              _results2 = [];
              for (_m = 0, _len = threatenedSquares.length; _m < _len; _m++) {
                sq = threatenedSquares[_m];
                _results2.push(sq.threats.push(piece));
              }
              return _results2;
            })());
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  sendMove = function(startSquare, endSquare) {
    var moveInfo, pieceName, _ref;
    pieceName = (_ref = startSquare.piece) != null ? _ref.text : void 0;
    if (pieceName == null) {
      console.log("Cannot send move if start square is empty");
      return;
    }
    moveInfo = {
      player: sessionId,
      piece: pieceName,
      startSquare: [startSquare.x, startSquare.y],
      endSquare: [endSquare.x, endSquare.y]
    };
    return socket.emit('newMove', moveInfo);
  };

  /*
  drawBoard = (canvas) ->
    createRectangle = (x, y, color) ->
      rectangle = canvas.display.rectangle( {
        x: x,
        y: y,
        width: squareSize; 
        height: squareSize; 
        fill: color; 
      })
      canvas.addChild(rectangle)
  
    for x in [0..7]
      for y in [0..7]
        board[x][y].graphic = createRectangle(x * squareSize, y * squareSize, if (y + x) % 2 == 0 then light else dark)
        #console.log "#{x}, #{y}"
  */


  isObstructed = function(startSquare, endSquare, board) {
    var col, i, j, row, slope, xDist, xRange, yDist, yRange, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _results, _results1;
    if (endSquare.x === startSquare.x) {
      i = Math.min(startSquare.y, endSquare.y) + 1;
      j = Math.max(startSquare.y, endSquare.y) - 1;
      if (j - i < 0) {
        return false;
      }
      for (row = _i = i; i <= j ? _i <= j : _i >= j; row = i <= j ? ++_i : --_i) {
        if (board[startSquare.x][row].piece != null) {
          return true;
        }
      }
    }
    if (endSquare.y === startSquare.y) {
      i = Math.min(startSquare.x, endSquare.x) + 1;
      j = Math.max(startSquare.x, endSquare.x) - 1;
      if (j - i < 0) {
        return false;
      }
      for (col = _j = i; i <= j ? _j <= j : _j >= j; col = i <= j ? ++_j : --_j) {
        if (board[col][startSquare.y].piece != null) {
          return true;
        }
      }
    }
    xDist = endSquare.x - startSquare.x;
    yDist = endSquare.y - startSquare.y;
    slope = xDist / yDist;
    if (Math.abs(slope) === 1 && Math.abs(xDist) > 1 && Math.abs(yDist) > 1) {
      xRange = (function() {
        _results = [];
        for (var _k = _ref = startSquare.x, _ref1 = endSquare.x; _ref <= _ref1 ? _k <= _ref1 : _k >= _ref1; _ref <= _ref1 ? _k++ : _k--){ _results.push(_k); }
        return _results;
      }).apply(this).slice(1, -1);
      yRange = (function() {
        _results1 = [];
        for (var _l = _ref2 = startSquare.y, _ref3 = endSquare.y; _ref2 <= _ref3 ? _l <= _ref3 : _l >= _ref3; _ref2 <= _ref3 ? _l++ : _l--){ _results1.push(_l); }
        return _results1;
      }).apply(this).slice(1, -1);
      for (i = _m = 0, _ref4 = xRange.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
        if (board[xRange[i]][yRange[i]].piece != null) {
          return true;
        }
      }
    }
    return false;
  };

}).call(this);
