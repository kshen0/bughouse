// Generated by CoffeeScript 1.6.3
(function() {
  var Board, COLORS, boards, getRoomId, handleConnectResponse, init, playerColor, playerGameNum, serverBaseUrl, sessionId, socket, squareSize,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.Game = window.Game || {};

  serverBaseUrl = document.domain;

  socket = io.connect(serverBaseUrl);

  sessionId = '';

  COLORS = {
    red: "#e74c3c",
    dark: "#34495e",
    light: "#95a5a6",
    green: "#27ae60"
  };

  squareSize = 50;

  boards = {
    one: {},
    two: {}
  };

  playerGameNum = 'unknown';

  playerColor = void 0;

  oCanvas.domReady(function() {
    return init();
  });

  getRoomId = function() {
    var url;
    url = document.URL.split("/");
    return url[url.length - 1];
  };

  init = function() {
    var boardNum, canvas, roomId, _i, _len, _ref;
    _ref = ["one", "two"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      boardNum = _ref[_i];
      canvas = oCanvas.create({
        canvas: "#board-" + boardNum,
        background: COLORS.green
      });
      canvas.height = 8 * squareSize;
      canvas.width = 12 * squareSize;
      boards[boardNum].canvas = canvas;
    }
    roomId = getRoomId();
    console.log("connected to game " + roomId);
    return socket.on('connect', function() {
      sessionId = socket.socket.sessionid;
      console.log("sessionId " + sessionId);
      socket.emit('newUser', {
        id: sessionId,
        name: "player"
      });
      return $.get("/game/player/info/" + sessionId, handleConnectResponse);
    });
    /*
    socket.on 'newMove', (moveInfo) ->
      return if moveInfo.player is sessionId
      start = moveInfo.startSquare
      end = moveInfo.endSquare
      console.log "new incoming move #{moveInfo.piece} #{start}-#{end}"
      game = games[moveInfo.gameId]
      startSquare = game.board[start[0]][start[1]]
      endSquare = game.board[end[0]][end[1]]
      game.moveSuccess startSquare.piece.displayObject, startSquare, endSquare
    
    socket.on 'newDrop', (dropInfo) ->
      return if dropInfo.player is sessionId
      end = dropInfo.endSquare
      console.log "new incoming drop #{dropInfo.piece} on #{end}"
      game = games[dropInfo.gameId]
      endSquare = game.board[end[0]][end[1]]
      game.dropSuccess game.getUnplacedPieceIndex(dropInfo.piece), endSquare
    
    socket.on 'transferPiece', (pieceInfo) ->
      console.log "transfer piece"
      console.log pieceInfo
      targetGame = if pieceInfo.gameId is 'one' then 'two' else 'one'
      #if playerColor is pieceInfo.color and playerGameNum is targetGame 
      games[targetGame].addPieceToGame(pieceInfo)
    */

  };

  handleConnectResponse = function(resp) {
    var roomId;
    playerColor = resp.color;
    playerGameNum = resp.gameNum;
    $('#player-label').text("You are " + playerColor + " on board " + playerGameNum);
    roomId = getRoomId();
    return $.get("/game/status/" + roomId, function(resp) {
      boards.one.board = new Board(resp.boards.one, "white", boards.one.canvas, "one");
      return boards.two.board = new Board(resp.boards.two, "white", boards.two.canvas, "two");
    });
  };

  Board = (function() {
    Board.prototype.A = 7;

    Board.prototype.B = 6;

    Board.prototype.C = 5;

    Board.prototype.D = 4;

    Board.prototype.E = 3;

    Board.prototype.F = 2;

    Board.prototype.G = 1;

    Board.prototype.H = 0;

    Board.prototype.startSquare = void 0;

    Board.prototype.startX = void 0;

    Board.prototype.startY = void 0;

    Board.prototype.endSquare = void 0;

    Board.prototype.dragLock = false;

    Board.prototype.check = false;

    Board.prototype.canvas = void 0;

    Board.prototype.boardSquares = [];

    Board.prototype.board = void 0;

    Board.prototype.playerColor = void 0;

    Board.prototype.whitesTurn = true;

    function Board(boardParams, playerColor, canvas, gameId) {
      this.playerColor = playerColor;
      this.canvas = canvas;
      this.gameId = gameId;
      this.isObstructed = __bind(this.isObstructed, this);
      this.sendMove = __bind(this.sendMove, this);
      this.moveSuccess = __bind(this.moveSuccess, this);
      this.resetBoardColor = __bind(this.resetBoardColor, this);
      this.drawPieces = __bind(this.drawPieces, this);
      this.dropPiece = __bind(this.dropPiece, this);
      this.pickUpPiece = __bind(this.pickUpPiece, this);
      this.undrawThreat = __bind(this.undrawThreat, this);
      this.drawThreat = __bind(this.drawThreat, this);
      this.createBoard(boardParams);
      this.drawPieces();
      canvas.redraw();
      /*
      @calculateThreat()
      @unplacedPieces = []
      */

    }

    Board.prototype.createBoard = function(boardParams) {
      var boardState, letter, letters, num, pieceParams, type, unplacedPieces, x, y, _i, _results;
      boardState = boardParams.board;
      unplacedPieces = boardParams.unplacedPieces;
      letters = (function() {
        var _i, _results;
        _results = [];
        for (letter = _i = 72; _i >= 65; letter = --_i) {
          _results.push(String.fromCharCode(letter));
        }
        return _results;
      })();
      this.board = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = letters.length; _i < _len; _i++) {
          letter = letters[_i];
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (num = _j = 1; _j <= 8; num = ++_j) {
              _results1.push(new window.Square("" + letter + num, num, letter));
            }
            return _results1;
          })());
        }
        return _results;
      })();
      _results = [];
      for (y = _i = 0; _i <= 7; y = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (x = _j = 0; _j <= 7; x = ++_j) {
            this.board[x][y].x = x;
            this.board[x][y].y = y;
            this.board[x][y].graphic = this.createRectangle(x * squareSize, y * squareSize, (y + x) % 2 === 0 ? COLORS.light : COLORS.dark);
            this.board[x][y].threat = boardState[x][y].threat;
            this.board[x][y].threats = boardState[x][y].threats;
            pieceParams = boardState[x][y].piece;
            if (pieceParams != null) {
              type = pieceParams.text;
              if (type === "pawn") {
                console.log("pawn at " + x + ", " + y);
                _results1.push(this.board[x][y].piece = new window.Pawn(pieceParams));
              } else if (type === "knight") {
                _results1.push(this.board[x][y].piece = new window.Knight(pieceParams));
              } else if (type === "bishop") {
                _results1.push(this.board[x][y].piece = new window.Bishop(pieceParams));
              } else if (type === "rook") {
                _results1.push(this.board[x][y].piece = new window.Rook(pieceParams));
              } else if (type === "king") {
                _results1.push(this.board[x][y].piece = new window.King(pieceParams));
              } else if (type === "queen") {
                _results1.push(this.board[x][y].piece = new window.Queen(pieceParams));
              } else {
                _results1.push(void 0);
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.createRectangle = function(x, y, color) {
      var rectangle;
      rectangle = this.canvas.display.rectangle({
        x: x,
        y: y,
        width: squareSize,
        height: squareSize,
        fill: color
      });
      this.canvas.addChild(rectangle);
      return rectangle;
    };

    Board.prototype.drawThreat = function(img) {
      if (this.dragLock) {
        return void 0;
      }
      this.setSquareColorForImg(img, COLORS.red);
      return this.canvas.redraw();
    };

    Board.prototype.undrawThreat = function(img) {
      if (this.dragLock) {
        return void 0;
      }
      this.setSquareColorForImg(img);
      return this.canvas.redraw();
    };

    Board.prototype.pickUpPiece = function(displayObj) {
      var piece;
      piece = displayObj.piece;
      if (displayObj.piece == null) {
        console.log("could not find a piece for this display object");
        console.log(displayObj);
        return;
      }
      this.dragLock = true;
      this.resetBoardColor();
      this.startX = displayObj.x;
      this.startY = displayObj.y;
      if (piece.placed) {
        return this.startSquare = this.board[Math.floor(displayObj.x / squareSize)][Math.floor(displayObj.y / squareSize)];
      }
    };

    Board.prototype.dropPiece = function(displayObj, playerColor) {
      var piece, revert,
        _this = this;
      piece = displayObj.piece;
      if (piece == null) {
        console.log("No piece selected");
        this.dragLock = false;
        return;
      }
      revert = function() {
        displayObj.x = _this.startX;
        displayObj.y = _this.startY;
        return _this.dragLock = false;
      };
      if (playerGameNum !== this.gameId) {
        console.log("player is playing on board " + playerGameNum + " and cannot move pieces on board " + this.gameId);
        revert();
        return;
      }
      if (piece.color !== this.playerColor) {
        console.log("Player is " + this.playerColor + ". Can't move " + piece.color + " piece.");
        revert();
        return;
      }
      if (this.playerColor === 'white' && !this.whitesTurn || this.playerColor === 'black' && this.whitesTurn) {
        console.log("" + this.playerColor + " cannot move out of turn");
        revert();
        return;
      }
      this.endSquare = this.board[Math.floor(displayObj.x / squareSize)][Math.floor(displayObj.y / squareSize)];
      if (piece.placed) {
        return piece.move(this.startSquare, this.endSquare, function(isValid) {
          var colorturn;
          if (!isValid || _this.isObstructed(_this.startSquare, _this.endSquare, _this.board)) {
            return revert();
          } else if (_this.check) {
            if (!_this.isCheckRemoved(_this.startSquare, _this.endSquare)) {
              colorturn = _this.whitesTurn ? "white" : "black";
              console.log("" + colorturn + " is in check; must move king or block check");
              alert("" + colorturn + " is in check; must move king or block check");
              return revert();
            } else {
              return _this.moveSuccess(displayObj, _this.startSquare, _this.endSquare, true);
            }
          } else {
            return _this.moveSuccess(displayObj, _this.startSquare, _this.endSquare, true);
          }
        });
      } else if (piece.placed === false) {
        if (this.endSquare.piece != null) {
          console.log("cannot place a piece on an occupied square");
          revert();
        } else {
          return this.dropSuccess(this.getUnplacedPieceIndex(piece.name), this.endSquare, true);
        }
      } else {
        console.log("unhandled piece state");
        console.log(piece);
      }
    };

    /*
    
    getUnplacedPieceIndex: (pieceName) =>
      for i in [0...@unplacedPieces.length]
        console.log "compare: "
        console.log @unplacedPieces[i]
        console.log " with "
        console.log pieceName
        if @unplacedPieces[i].name is pieceName
          return i
    */


    Board.prototype.drawPieces = function(canvas, board) {
      var img, that, x, y, _i, _j, _k, _ref, _results;
      for (x = _i = 0; _i <= 7; x = ++_i) {
        for (y = _j = 0; _j <= 7; y = ++_j) {
          if (((_ref = this.board[x][y].piece) != null ? _ref.displayObject : void 0) != null) {
            this.board[x][y].piece.displayObject.remove();
          }
        }
      }
      _results = [];
      for (x = _k = 0; _k <= 7; x = ++_k) {
        _results.push((function() {
          var _l, _results1;
          _results1 = [];
          for (y = _l = 0; _l <= 7; y = ++_l) {
            if (this.board[x][y].piece != null) {
              img = this.canvas.display.image({
                x: x * squareSize + squareSize / 2,
                y: y * squareSize + squareSize / 2,
                origin: {
                  x: "center",
                  y: "center"
                },
                height: squareSize,
                width: squareSize,
                image: this.board[x][y].piece.graphic
              });
              this.board[x][y].piece.displayObject = img;
              this.canvas.addChild(img);
              img.piece = this.board[x][y].piece;
              that = this;
              img.bind("mouseenter", function() {
                return that.drawThreat(this);
              });
              img.bind("mouseleave", function() {
                return that.undrawThreat(this);
              });
              _results1.push(img.dragAndDrop({
                start: function() {
                  return that.pickUpPiece(this);
                },
                end: function() {
                  return that.dropPiece(this);
                }
              }));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    /*
    
    drawUnplacedPieces: () =>
      for piece in @unplacedPieces
        img = @canvas.display.image({
          x: squareSize * 8 + squareSize / 2
          y: squareSize / 2 
          origin: {x: "center", y: "center"}
          height: squareSize
          width: squareSize
          image: piece.graphic
        })
        piece.displayObject = img
        @canvas.addChild(img)
        img.piece = piece
    
        # define drag and drop behavior
        instance = @
        img.dragAndDrop 
          start: () ->
            instance.pickUpPiece @
    
          end: () ->
            instance.dropPiece @
    */


    Board.prototype.resetBoardColor = function() {
      var x, y, _i, _results;
      _results = [];
      for (y = _i = 0; _i <= 7; y = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (x = _j = 0; _j <= 7; x = ++_j) {
            if ((y + x) % 2 === 0) {
              _results1.push(this.board[x][y].graphic.fill = COLORS.light);
            } else {
              _results1.push(this.board[x][y].graphic.fill = COLORS.dark);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.setSquareColorForImg = function(img, color) {
      var piece, sq, square, threatenedSqs, x, y, _i, _len, _results;
      x = Math.floor(img.x / squareSize);
      y = Math.floor(img.y / squareSize);
      square = this.board[x][y];
      piece = square.piece;
      if (piece == null) {
        return;
      }
      threatenedSqs = piece.getThreatenedSquares(this.board, x, y);
      _results = [];
      for (_i = 0, _len = threatenedSqs.length; _i < _len; _i++) {
        sq = threatenedSqs[_i];
        _results.push(sq != null ? sq.graphic.fill = color || ((sq.y + sq.x) % 2 === 0 ? COLORS.light : COLORS.dark) : void 0);
      }
      return _results;
    };

    Board.prototype.moveSuccess = function(displayObj, startSquare, endSquare, movedBySelf) {
      var capturedPiece;
      if (displayObj == null) {
        console.log("invalid displayObj: " + displayObj);
        return;
      }
      if (movedBySelf) {
        this.sendMove(startSquare, endSquare);
      }
      console.log("" + startSquare.piece.text + " " + startSquare.name + "-" + endSquare.name);
      capturedPiece = endSquare.piece;
      if (capturedPiece != null) {
        capturedPiece.displayObject.remove();
        if (movedBySelf) {
          socket.emit('capturePiece', {
            gameId: this.gameId,
            piece: capturedPiece.name,
            color: capturedPiece.color
          });
        }
      }
      startSquare.piece.square = endSquare;
      endSquare.piece = startSquare.piece;
      startSquare.piece = void 0;
      displayObj.x = (endSquare.x * squareSize) + squareSize / 2;
      displayObj.y = (endSquare.y * squareSize) + squareSize / 2;
      if (endSquare.piece.text === 'pawn') {
        if (endSquare.piece.color === 'white' && endSquare.y === 7) {
          console.log('promote white pawn');
          this.drawPromoteDialog('white', endSquare);
        }
        if (endSquare.piece.color === 'black' && endSquare.y === 0) {
          console.log('promote black pawn');
        }
      }
      this.dragLock = false;
      this.canvas.redraw();
      return this.toggleTurn();
    };

    /*
    
    drawPromoteDialog: (color, endSquare) =>
      width = 4 * squareSize;
      height = 1.5 * squareSize;
      rectangle = @canvas.display.rectangle( {
        x: squareSize * 4 - width / 2,
        y: squareSize * 4 - height / 2,
        width: width,
        height: height,
        fill: COLORS.green; 
      })
    
      pieces = ['knight', 'bishop', 'rook', 'queen']
      for pieceName, i in pieces
        sprite = @canvas.display.image({
          x: squareSize * i
          y: squareSize / 4 
          origin: {x: "left", y: "left"}
          height: squareSize
          width: squareSize
          image: "img/#{pieceName}_#{color}.png"
        })
    
    
        that = @
        console.log "bind #{pieceName}"
        # TODO: figure out why this always binds the last piece name
        sprite.bind "click", () ->
          that.createPiece @, color, endSquare, rectangle
        rectangle.addChild(sprite)
    
      @canvas.addChild(rectangle)
    
    createPiece: (eventInfo, color, endSquare, picker) =>
      filename = eventInfo.img?.src
      if not filename?
        console.log "no imagename found in createPiece"
        return
    
      if endSquare.piece?
        endSquare.piece.displayObject.remove()
    
      # sorry not sorry
      if filename.indexOf('knight') > -1 
        endSquare.piece = new window.Knight(color, "knight", true)
      else if filename.indexOf('bishop') > -1 
        endSquare.piece = new window.Bishop(color, "bishop", true)
      else if filename.indexOf('rook') > -1 
        endSquare.piece = new window.Rook(color, "rook", true)
      else if filename.indexOf('queen') > -1 
        endSquare.piece = new window.Queen(color, "queen", true)
    
      picker.remove()
    
      @drawPieces()
      @canvas.redraw()
    
    dropSuccess: (index, endSquare, movedBySelf) =>
      console.log "dropsuccess"
    
      piece = @unplacedPieces[index]
    
      if movedBySelf
        @sendDrop(index, endSquare)
      @unplacedPieces.splice index, 1
    
      displayObj = piece.displayObject
    
      console.log "dropping #{piece.name} at #{endSquare.name}"
    
      # add the piece to the board 
      endSquare.piece = piece
      piece.square = endSquare
      piece.placed = true 
    
      # bind hover listener
      that = @
      displayObj.bind "mouseenter", () ->
        that.drawThreat @
      displayObj.bind "mouseleave", () ->
        that.undrawThreat @
    
      # update the graphic
      displayObj.x = (endSquare.x * squareSize) + squareSize / 2
      displayObj.y = (endSquare.y * squareSize) + squareSize / 2
    
      @dragLock = false
      @calculateThreat()
      @canvas.redraw()
      @toggleTurn()
    */


    Board.prototype.toggleTurn = function() {
      this.whitesTurn = !this.whitesTurn;
      if (this.whitesTurn) {
        $('#turn-label').text("White's turn");
      } else {
        $('#turn-label').text("Black's turn");
      }
      this.calculateThreat();
      this.resetColors();
      return this.check = this.checkForCheck();
    };

    /*
    isCheckRemoved: () ->
      if not @check
        console.log "player is not in check to begin with!"
        return false
    
      # temporarily change board to assess check
      endSqPiece = @endSquare.piece
      @startSquare.piece.square = @endSquare
      @endSquare.piece = @startSquare.piece
      @startSquare.piece = undefined
      @calculateThreat()
      newCheck = @checkForCheck()
    
      # reset from temporary position
      @endSquare.piece.square = @startSquare
      @startSquare.piece = @endSquare.piece
      @endSquare.piece = endSqPiece
      @calculateThreat()
    
      return newCheck is false
    
    checkForCheck: () ->
      # find king
      kingSq = undefined
      colorTurn = if @whitesTurn then "white" else "black"
      for x in [0..7]
        for y in [0..7]
          if @board[x][y].piece?.name is "#{colorTurn} king"
            kingSq = @board[x][y]
    
      for piece in kingSq.threats
        if piece.color isnt colorTurn
          console.log "#{colorTurn} is in check"
          return true
    
      return false
    
    resetColors: () ->
      for x in [0..7]
        for y in [0..7]
          @setSquareColorForImg @board[x][y].graphic
    
    calculateThreat: () =>
      # reset threat for each square
      for x in [0..7]
        for y in [0..7]
          @board[x][y].threats = []
    
      # calculate threat for each piece
      for x in [0..7]
        for y in [0..7]
          piece = @board[x][y].piece
          if piece?
            threatenedSquares = piece.getThreatenedSquares(@board, x, y)
            for sq in threatenedSquares
              sq.threats.push piece
    */


    Board.prototype.sendMove = function(startSquare, endSquare) {
      var moveInfo, pieceName, roomId, _ref;
      roomId = getRoomId();
      pieceName = (_ref = startSquare.piece) != null ? _ref.text : void 0;
      if (pieceName == null) {
        console.log("Cannot send move if start square is empty");
        return;
      }
      moveInfo = {
        roomId: roomId,
        player: sessionId,
        piece: pieceName,
        startSquare: [startSquare.x, startSquare.y],
        endSquare: [endSquare.x, endSquare.y],
        gameId: this.gameId
      };
      return socket.emit('newMove', moveInfo);
    };

    /*
    sendDrop: (index, endSquare) =>
      console.log "send drop"
      console.log "index: #{index}"
      console.log "endsquare: #{endSquare.name}"
      console.log @unplacedPieces
      pieceName = @unplacedPieces[index]?.text
      pieceColor = @unplacedPieces[index]?.color
      if not pieceName?
        console.log "Error finding piece to drop"
        return
    
      dropInfo =
        player: sessionId
        piece: "#{pieceColor} #{pieceName}"
        endSquare: [endSquare.x, endSquare.y]
        gameId: @gameId
    
      socket.emit 'newDrop', dropInfo
    
    addPieceToGame: (pieceInfo) =>
      console.log "adding piece to game:"
      console.log pieceInfo
    
      pieceName = pieceInfo.piece
      return unless pieceName? 
      colorAndType = pieceName.split " "
      return unless colorAndType.length is 2
      color = colorAndType[0]
      type = colorAndType[1]
    
      if type is "pawn"
        piece = new window.Pawn(color, type, false)
      if type is "rook"
        piece = new window.Pawn(color, type, false)
      if type is "knight"
        piece = new window.Pawn(color, type, false)
      if type is "bishop"
        piece = new window.Pawn(color, type, false)
      if type is "queen"
        piece = new window.Pawn(color, type, false)
    
      return unless piece?
    
      @unplacedPieces.push piece
      @drawUnplacedPieces()
    */


    Board.prototype.isObstructed = function(startSquare, endSquare, board) {
      var col, i, j, row, slope, xDist, xRange, yDist, yRange, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _results, _results1;
      if (endSquare.x === startSquare.x) {
        i = Math.min(startSquare.y, endSquare.y) + 1;
        j = Math.max(startSquare.y, endSquare.y) - 1;
        if (j - i < 0) {
          return false;
        }
        for (row = _i = i; i <= j ? _i <= j : _i >= j; row = i <= j ? ++_i : --_i) {
          if (this.board[startSquare.x][row].piece != null) {
            return true;
          }
        }
      }
      if (endSquare.y === startSquare.y) {
        i = Math.min(startSquare.x, endSquare.x) + 1;
        j = Math.max(startSquare.x, endSquare.x) - 1;
        if (j - i < 0) {
          return false;
        }
        for (col = _j = i; i <= j ? _j <= j : _j >= j; col = i <= j ? ++_j : --_j) {
          if (this.board[col][startSquare.y].piece != null) {
            return true;
          }
        }
      }
      xDist = endSquare.x - startSquare.x;
      yDist = endSquare.y - startSquare.y;
      slope = xDist / yDist;
      if (Math.abs(slope) === 1 && Math.abs(xDist) > 1 && Math.abs(yDist) > 1) {
        xRange = (function() {
          _results = [];
          for (var _k = _ref = startSquare.x, _ref1 = endSquare.x; _ref <= _ref1 ? _k <= _ref1 : _k >= _ref1; _ref <= _ref1 ? _k++ : _k--){ _results.push(_k); }
          return _results;
        }).apply(this).slice(1, -1);
        yRange = (function() {
          _results1 = [];
          for (var _l = _ref2 = startSquare.y, _ref3 = endSquare.y; _ref2 <= _ref3 ? _l <= _ref3 : _l >= _ref3; _ref2 <= _ref3 ? _l++ : _l--){ _results1.push(_l); }
          return _results1;
        }).apply(this).slice(1, -1);
        for (i = _m = 0, _ref4 = xRange.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
          if (this.board[xRange[i]][yRange[i]].piece != null) {
            return true;
          }
        }
      }
      return false;
    };

    return Board;

  })();

}).call(this);
