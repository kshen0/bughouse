// Generated by CoffeeScript 1.6.3
(function() {
  var COLORS, ChessGame, games, init, serverBaseUrl, sessionId, socket, squareSize,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.Game = window.Game || {};

  serverBaseUrl = document.domain;

  socket = io.connect(serverBaseUrl);

  sessionId = '';

  COLORS = {
    red: "#e74c3c",
    dark: "#34495e",
    light: "#95a5a6"
  };

  squareSize = 70;

  games = {
    one: void 0,
    two: void 0
  };

  oCanvas.domReady(function() {
    return init();
    /*
    canvas = oCanvas.create {canvas: "#board", background: COLORS.dark}
    canvas.height = 8 * squareSize;
    canvas.width = 8 * squareSize; 
    games.one = new ChessGame(canvas)
    games.one.drawPieces()
    */

  });

  init = function() {
    socket.on('connect', function() {
      sessionId = socket.socket.sessionid;
      console.log("sessionId " + sessionId);
      socket.emit('newUser', {
        id: sessionId,
        name: "player"
      });
      return $.get("/game/playercolor/" + sessionId, function(resp) {
        var canvas, playerColor;
        playerColor = resp;
        console.log("player color is " + playerColor);
        canvas = oCanvas.create({
          canvas: "#board",
          background: COLORS.dark
        });
        canvas.height = 8 * squareSize;
        canvas.width = 8 * squareSize;
        games.one = new ChessGame(canvas, playerColor, 'one');
        return games.one.drawPieces();
      });
    });
    return socket.on('newMove', function(moveInfo) {
      var end, endSquare, game, start, startSquare;
      if (moveInfo.player === sessionId) {
        return;
      }
      console.log("moveInfo");
      console.log(moveInfo);
      start = moveInfo.startSquare;
      end = moveInfo.endSquare;
      console.log("new incoming move " + moveInfo.piece + " " + start + "-" + end);
      game = games[moveInfo.gameId];
      startSquare = game.board[start[0]][start[1]];
      endSquare = game.board[end[0]][end[1]];
      return game.moveSuccess(startSquare.piece.displayObject, startSquare, endSquare);
    });
  };

  ChessGame = (function() {
    var isObstructed;

    function ChessGame(canvas, playerColor, gameId) {
      this.canvas = canvas;
      this.playerColor = playerColor;
      this.gameId = gameId;
      this.sendMove = __bind(this.sendMove, this);
      this.calculateThreat = __bind(this.calculateThreat, this);
      this.moveSuccess = __bind(this.moveSuccess, this);
      this.resetBoardColor = __bind(this.resetBoardColor, this);
      this.drawPieces = __bind(this.drawPieces, this);
      this.dropPiece = __bind(this.dropPiece, this);
      this.pickUpPiece = __bind(this.pickUpPiece, this);
      this.undrawThreat = __bind(this.undrawThreat, this);
      this.drawThreat = __bind(this.drawThreat, this);
      this.createRectangle = __bind(this.createRectangle, this);
      this.createBoard = __bind(this.createBoard, this);
      this.board = this.createBoard(this.canvas);
      this.calculateThreat();
    }

    ChessGame.prototype.A = 7;

    ChessGame.prototype.B = 6;

    ChessGame.prototype.C = 5;

    ChessGame.prototype.D = 4;

    ChessGame.prototype.E = 3;

    ChessGame.prototype.F = 2;

    ChessGame.prototype.G = 1;

    ChessGame.prototype.H = 0;

    ChessGame.prototype.startSquare = void 0;

    ChessGame.prototype.startX = void 0;

    ChessGame.prototype.startY = void 0;

    ChessGame.prototype.endSquare = void 0;

    ChessGame.prototype.dragLock = false;

    ChessGame.prototype.check = false;

    ChessGame.prototype.canvas = void 0;

    ChessGame.prototype.boardSquares = [];

    ChessGame.prototype.board = void 0;

    ChessGame.prototype.playerColor = void 0;

    ChessGame.prototype.whitesTurn = true;

    ChessGame.prototype.createBoard = function(canvas) {
      var board, letter, letters, num, x, y, _i, _j, _k, _l;
      letters = (function() {
        var _i, _results;
        _results = [];
        for (letter = _i = 72; _i >= 65; letter = --_i) {
          _results.push(String.fromCharCode(letter));
        }
        return _results;
      })();
      board = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = letters.length; _i < _len; _i++) {
          letter = letters[_i];
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (num = _j = 1; _j <= 8; num = ++_j) {
              _results1.push(new window.Square("" + letter + num, num, letter));
            }
            return _results1;
          })());
        }
        return _results;
      })();
      for (y = _i = 0; _i <= 7; y = ++_i) {
        for (x = _j = 0; _j <= 7; x = ++_j) {
          board[x][y].x = x;
          board[x][y].y = y;
        }
      }
      /*
      for col in [0..7]
        board[col][1].piece = new window.Pawn("white", "pawn")
        board[col][6].piece = new window.Pawn("black", "pawn")
      
      # Rooks
      board[@A][0].piece = new window.Rook("white", "rook")
      board[@H][0].piece = new window.Rook("white", "rook")
      board[@A][7].piece = new window.Rook("black", "rook")
      board[@H][7].piece = new window.Rook("black", "rook")
      
      # Knights 
      board[@B][0].piece = new window.Knight("white", "knight")
      board[@G][0].piece = new window.Knight("white", "knight")
      board[@B][7].piece = new window.Knight("black", "knight")
      board[@G][7].piece = new window.Knight("black", "knight")
      
      # Bishops
      board[@C][0].piece = new window.Bishop("white", "bishop")
      board[@F][0].piece = new window.Bishop("white", "bishop")
      board[@C][7].piece = new window.Bishop("black", "bishop")
      board[@F][7].piece = new window.Bishop("black", "bishop")
      */

      board[this.E][0].piece = new window.King("white", "king");
      board[this.E][7].piece = new window.King("black", "king");
      board[this.D][0].piece = new window.Queen("white", "queen");
      board[this.D][7].piece = new window.Queen("black", "queen");
      for (x = _k = 0; _k <= 7; x = ++_k) {
        for (y = _l = 0; _l <= 7; y = ++_l) {
          board[x][y].graphic = this.createRectangle(x * squareSize, y * squareSize, (y + x) % 2 === 0 ? COLORS.light : COLORS.dark);
        }
      }
      return board;
    };

    ChessGame.prototype.createRectangle = function(x, y, color) {
      var rectangle;
      rectangle = this.canvas.display.rectangle({
        x: x,
        y: y,
        width: squareSize,
        height: squareSize,
        fill: color
      });
      this.canvas.addChild(rectangle);
      return rectangle;
    };

    ChessGame.prototype.drawThreat = function(img) {
      if (this.dragLock) {
        return void 0;
      }
      this.setSquareColorForImg(img, COLORS.red);
      return this.canvas.redraw();
    };

    ChessGame.prototype.undrawThreat = function(img) {
      if (this.dragLock) {
        return void 0;
      }
      this.setSquareColorForImg(img);
      return this.canvas.redraw();
    };

    ChessGame.prototype.pickUpPiece = function(piece) {
      this.dragLock = true;
      this.resetBoardColor();
      this.startX = piece.x;
      this.startY = piece.y;
      console.log(piece);
      return this.startSquare = this.board[Math.floor(piece.x / squareSize)][Math.floor(piece.y / squareSize)];
    };

    ChessGame.prototype.dropPiece = function(displayObj, playerColor) {
      var piece, revert,
        _this = this;
      piece = this.startSquare.piece;
      if (piece == null) {
        console.log("No piece selected");
        return;
      }
      revert = function() {
        displayObj.x = _this.startX;
        return displayObj.y = _this.startY;
      };
      console.log("player color: " + this.playerColor);
      if (piece.color !== this.playerColor) {
        console.log("Player is " + this.playerColor + ". Can't move " + piece.color + " piece.");
        revert();
        return;
      }
      if (this.playerColor === 'white' && !this.whitesTurn || this.playerColor === 'black' && this.whitesTurn) {
        console.log("" + this.playerColor + " cannot move out of turn");
        revert();
        return;
      }
      this.endSquare = this.board[Math.floor(displayObj.x / squareSize)][Math.floor(displayObj.y / squareSize)];
      return piece.move(this.startSquare, this.endSquare, function(isValid) {
        var colorturn;
        if (!isValid || isObstructed(_this.startSquare, _this.endSquare, _this.board)) {
          return revert();
        } else if (_this.check) {
          if (!_this.isCheckRemoved(_this.startSquare, _this.endSquare)) {
            colorturn = _this.whitesTurn ? "white" : "black";
            console.log("" + colorturn + " is in check; must move king or block check");
            alert("" + colorturn + " is in check; must move king or block check");
            return revert();
          } else {
            return _this.moveSuccess(displayObj, _this.startSquare, _this.endSquare, true);
          }
        } else {
          return _this.moveSuccess(displayObj, _this.startSquare, _this.endSquare, true);
        }
      });
    };

    ChessGame.prototype.drawPieces = function(canvas, board) {
      var img, instance, that, x, y, _i, _results;
      _results = [];
      for (x = _i = 0; _i <= 7; x = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j <= 7; y = ++_j) {
            if (this.board[x][y].piece != null) {
              img = this.canvas.display.image({
                x: x * squareSize + squareSize / 2,
                y: y * squareSize + squareSize / 2,
                origin: {
                  x: "center",
                  y: "center"
                },
                image: this.board[x][y].piece.graphic
              });
              this.board[x][y].piece.displayObject = img;
              this.canvas.addChild(img);
              that = this;
              img.bind("mouseenter", function() {
                return that.drawThreat(this, that.playerColor);
              });
              img.bind("mouseleave", function() {
                return that.undrawThreat(this, that.playerColor);
              });
              instance = this;
              _results1.push(img.dragAndDrop({
                start: function() {
                  return instance.pickUpPiece(this);
                  /*
                  @dragLock = true
                  @resetBoardColor()
                  startX = this.x
                  startY = this.y
                  startSquare = @board[Math.floor(this.x / squareSize)][Math.floor(this.y / squareSize)]
                  */

                },
                end: function() {
                  return instance.dropPiece(this);
                  /*
                  piece = startSquare.piece
                  
                  if not piece?
                    console.log "No piece selected"
                    return
                  
                  that = this
                  revert = () ->
                    that.x = startX
                    that.y = startY 
                  
                  if piece.color isnt playerColor
                    console.log "Player is #{playerColor}. Can't move #{piece.color} piece."
                    revert()
                    return
                  
                  if (playerColor is 'white' and not whitesTurn) or (playerColor is 'black' and whitesTurn)
                    console.log "#{playerColor} cannot move out of turn"
                    revert()
                    return
                  
                  endSquare = board[Math.floor(this.x / squareSize)][Math.floor(this.y / squareSize)]
                  piece.move startSquare, endSquare, (isValid) ->
                    if not isValid or isObstructed(startSquare, endSquare, board)
                      revert()
                    else if check
                      if not isCheckRemoved(startSquare, endSquare)
                        colorturn = if whitesTurn then "white" else "black"
                        console.log "#{colorturn} is in check; must move king or block check"
                        alert "#{colorturn} is in check; must move king or block check"
                        revert()
                      else
                        moveSuccess(that, startSquare, endSquare, true)
                    else
                      moveSuccess(that, startSquare, endSquare, true)
                  */

                }
              }));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ChessGame.prototype.resetBoardColor = function() {
      var x, y, _i, _results;
      _results = [];
      for (y = _i = 0; _i <= 7; y = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (x = _j = 0; _j <= 7; x = ++_j) {
            if ((y + x) % 2 === 0) {
              _results1.push(this.board[x][y].graphic.fill = COLORS.light);
            } else {
              _results1.push(this.board[x][y].graphic.fill = COLORS.dark);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ChessGame.prototype.setSquareColorForImg = function(img, color) {
      var piece, sq, square, threatenedSqs, x, y, _i, _len, _results;
      x = Math.floor(img.x / squareSize);
      y = Math.floor(img.y / squareSize);
      square = this.board[x][y];
      piece = square.piece;
      if (piece == null) {
        return;
      }
      threatenedSqs = piece.getThreatenedSquares(this.board, x, y);
      _results = [];
      for (_i = 0, _len = threatenedSqs.length; _i < _len; _i++) {
        sq = threatenedSqs[_i];
        _results.push(sq.graphic.fill = color || ((sq.y + sq.x) % 2 === 0 ? COLORS.light : COLORS.dark));
      }
      return _results;
    };

    ChessGame.prototype.moveSuccess = function(displayObj, startSquare, endSquare, movedBySelf) {
      if (displayObj == null) {
        console.log("invalid displayObj: " + displayObj);
        return;
      }
      if (movedBySelf) {
        this.sendMove(startSquare, endSquare);
      }
      console.log("" + startSquare.piece.text + " " + startSquare.name + "-" + endSquare.name);
      if (endSquare.piece != null) {
        endSquare.piece.displayObject.remove();
      }
      startSquare.piece.square = endSquare;
      endSquare.piece = startSquare.piece;
      startSquare.piece = void 0;
      displayObj.x = (endSquare.x * squareSize) + squareSize / 2;
      displayObj.y = (endSquare.y * squareSize) + squareSize / 2;
      this.toggleTurn();
      this.dragLock = false;
      return this.canvas.redraw();
    };

    ChessGame.prototype.toggleTurn = function() {
      this.whitesTurn = !this.whitesTurn;
      if (this.whitesTurn) {
        $('#turn-label').text("White's turn");
      } else {
        $('#turn-label').text("Black's turn");
      }
      this.calculateThreat();
      this.resetColors();
      return this.check = this.checkForCheck();
    };

    ChessGame.prototype.isCheckRemoved = function() {
      var newCheck;
      if (!this.check) {
        console.log("player is not in check to begin with!");
        return false;
      }
      console.log("recalculating check");
      this.startSquare.piece.square = this.endSquare;
      this.endSquare.piece = this.startSquare.piece;
      this.startSquare.piece = void 0;
      this.calculateThreat();
      newCheck = this.checkForCheck();
      this.endSquare.piece.square = this.startSquare;
      this.startSquare.piece = this.endSquare.piece;
      this.endSquare.piece = void 0;
      this.calculateThreat();
      console.log("check reevaluation = " + newCheck);
      return newCheck === false;
    };

    ChessGame.prototype.checkForCheck = function() {
      var colorTurn, kingSq, piece, x, y, _i, _j, _k, _len, _ref, _ref1;
      kingSq = void 0;
      colorTurn = this.whitesTurn ? "white" : "black";
      for (x = _i = 0; _i <= 7; x = ++_i) {
        for (y = _j = 0; _j <= 7; y = ++_j) {
          if (((_ref = this.board[x][y].piece) != null ? _ref.name : void 0) === ("" + colorTurn + " king")) {
            kingSq = this.board[x][y];
          }
        }
      }
      _ref1 = kingSq.threats;
      for (_k = 0, _len = _ref1.length; _k < _len; _k++) {
        piece = _ref1[_k];
        if (piece.color !== colorTurn) {
          alert("" + colorTurn + " is in check!");
          console.log("" + colorTurn + " is in check");
          return true;
        }
      }
      return false;
    };

    ChessGame.prototype.resetColors = function() {
      var x, y, _i, _results;
      _results = [];
      for (x = _i = 0; _i <= 7; x = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j <= 7; y = ++_j) {
            _results1.push(this.setSquareColorForImg(this.board[x][y].graphic));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ChessGame.prototype.calculateThreat = function() {
      var piece, sq, threatenedSquares, x, y, _i, _j, _k, _results;
      for (x = _i = 0; _i <= 7; x = ++_i) {
        for (y = _j = 0; _j <= 7; y = ++_j) {
          this.board[x][y].threats = [];
        }
      }
      _results = [];
      for (x = _k = 0; _k <= 7; x = ++_k) {
        _results.push((function() {
          var _l, _results1;
          _results1 = [];
          for (y = _l = 0; _l <= 7; y = ++_l) {
            piece = this.board[x][y].piece;
            if (piece != null) {
              threatenedSquares = piece.getThreatenedSquares(this.board, x, y);
              _results1.push((function() {
                var _len, _m, _results2;
                _results2 = [];
                for (_m = 0, _len = threatenedSquares.length; _m < _len; _m++) {
                  sq = threatenedSquares[_m];
                  _results2.push(sq.threats.push(piece));
                }
                return _results2;
              })());
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ChessGame.prototype.sendMove = function(startSquare, endSquare) {
      var moveInfo, pieceName, _ref;
      pieceName = (_ref = startSquare.piece) != null ? _ref.text : void 0;
      if (pieceName == null) {
        console.log("Cannot send move if start square is empty");
        return;
      }
      moveInfo = {
        player: sessionId,
        piece: pieceName,
        startSquare: [startSquare.x, startSquare.y],
        endSquare: [endSquare.x, endSquare.y],
        gameId: this.gameId
      };
      return socket.emit('newMove', moveInfo);
    };

    /*
    drawBoard = (canvas) ->
      createRectangle = (x, y, color) ->
        rectangle = canvas.display.rectangle( {
          x: x,
          y: y,
          width: squareSize; 
          height: squareSize; 
          fill: color; 
        })
        canvas.addChild(rectangle)
    
      for x in [0..7]
        for y in [0..7]
          board[x][y].graphic = createRectangle(x * squareSize, y * squareSize, if (y + x) % 2 == 0 then light else dark)
          #console.log "#{x}, #{y}"
    */


    isObstructed = function(startSquare, endSquare, board) {
      var col, i, j, row, slope, xDist, xRange, yDist, yRange, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _results, _results1;
      if (endSquare.x === startSquare.x) {
        i = Math.min(startSquare.y, endSquare.y) + 1;
        j = Math.max(startSquare.y, endSquare.y) - 1;
        if (j - i < 0) {
          return false;
        }
        for (row = _i = i; i <= j ? _i <= j : _i >= j; row = i <= j ? ++_i : --_i) {
          if (board[startSquare.x][row].piece != null) {
            return true;
          }
        }
      }
      if (endSquare.y === startSquare.y) {
        i = Math.min(startSquare.x, endSquare.x) + 1;
        j = Math.max(startSquare.x, endSquare.x) - 1;
        if (j - i < 0) {
          return false;
        }
        for (col = _j = i; i <= j ? _j <= j : _j >= j; col = i <= j ? ++_j : --_j) {
          if (board[col][startSquare.y].piece != null) {
            return true;
          }
        }
      }
      xDist = endSquare.x - startSquare.x;
      yDist = endSquare.y - startSquare.y;
      slope = xDist / yDist;
      if (Math.abs(slope) === 1 && Math.abs(xDist) > 1 && Math.abs(yDist) > 1) {
        xRange = (function() {
          _results = [];
          for (var _k = _ref = startSquare.x, _ref1 = endSquare.x; _ref <= _ref1 ? _k <= _ref1 : _k >= _ref1; _ref <= _ref1 ? _k++ : _k--){ _results.push(_k); }
          return _results;
        }).apply(this).slice(1, -1);
        yRange = (function() {
          _results1 = [];
          for (var _l = _ref2 = startSquare.y, _ref3 = endSquare.y; _ref2 <= _ref3 ? _l <= _ref3 : _l >= _ref3; _ref2 <= _ref3 ? _l++ : _l--){ _results1.push(_l); }
          return _results1;
        }).apply(this).slice(1, -1);
        for (i = _m = 0, _ref4 = xRange.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
          if (board[xRange[i]][yRange[i]].piece != null) {
            return true;
          }
        }
      }
      return false;
    };

    return ChessGame;

  })();

}).call(this);
