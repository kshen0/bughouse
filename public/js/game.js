// Generated by CoffeeScript 1.6.3
(function() {
  var COLORS, ChessGame, createGames, games, init, playerColor, playerGameNum, serverBaseUrl, sessionId, socket, squareSize,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.Game = window.Game || {};

  serverBaseUrl = document.domain;

  socket = io.connect(serverBaseUrl);

  sessionId = '';

  COLORS = {
    red: "#e74c3c",
    dark: "#34495e",
    light: "#95a5a6"
  };

  squareSize = 50;

  games = {
    one: void 0,
    two: void 0
  };

  playerGameNum = 'unknown';

  playerColor = void 0;

  oCanvas.domReady(function() {
    return init();
  });

  createGames = function(playerInfo) {
    var canvas, gameId, _i, _len, _ref, _results;
    playerColor = playerInfo.color;
    playerGameNum = playerInfo.gameNum;
    _ref = ['one', 'two'];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      gameId = _ref[_i];
      canvas = oCanvas.create({
        canvas: "#board-" + gameId,
        background: '#27ae60'
      });
      canvas.height = 8 * squareSize;
      canvas.width = 12 * squareSize;
      _results.push(games[gameId] = new ChessGame(canvas, playerColor, gameId));
    }
    return _results;
  };

  init = function() {
    socket.on('connect', function() {
      sessionId = socket.socket.sessionid;
      console.log("sessionId " + sessionId);
      socket.emit('newUser', {
        id: sessionId,
        name: "player"
      });
      return $.get("/game/player/info/" + sessionId, createGames);
    });
    socket.on('newMove', function(moveInfo) {
      var end, endSquare, game, start, startSquare;
      if (moveInfo.player === sessionId) {
        return;
      }
      start = moveInfo.startSquare;
      end = moveInfo.endSquare;
      console.log("new incoming move " + moveInfo.piece + " " + start + "-" + end);
      game = games[moveInfo.gameId];
      startSquare = game.board[start[0]][start[1]];
      endSquare = game.board[end[0]][end[1]];
      return game.moveSuccess(startSquare.piece.displayObject, startSquare, endSquare);
    });
    socket.on('newDrop', function(dropInfo) {
      var end, endSquare, game;
      if (dropInfo.player === sessionId) {
        return;
      }
      end = dropInfo.endSquare;
      console.log("new incoming drop " + dropInfo.piece + " on " + end);
      game = games[dropInfo.gameId];
      endSquare = game.board[end[0]][end[1]];
      return game.dropSuccess(game.getUnplacedPieceIndex(dropInfo.piece), endSquare);
    });
    return socket.on('transferPiece', function(pieceInfo) {
      var targetGame;
      console.log("transfer piece");
      console.log(pieceInfo);
      targetGame = pieceInfo.gameId === 'one' ? 'two' : 'one';
      return games[targetGame].addPieceToGame(pieceInfo);
    });
  };

  ChessGame = (function() {
    function ChessGame(canvas, playerColor, gameId) {
      this.canvas = canvas;
      this.playerColor = playerColor;
      this.gameId = gameId;
      this.isObstructed = __bind(this.isObstructed, this);
      this.addPieceToGame = __bind(this.addPieceToGame, this);
      this.sendDrop = __bind(this.sendDrop, this);
      this.sendMove = __bind(this.sendMove, this);
      this.calculateThreat = __bind(this.calculateThreat, this);
      this.dropSuccess = __bind(this.dropSuccess, this);
      this.moveSuccess = __bind(this.moveSuccess, this);
      this.resetBoardColor = __bind(this.resetBoardColor, this);
      this.drawUnplacedPieces = __bind(this.drawUnplacedPieces, this);
      this.drawPieces = __bind(this.drawPieces, this);
      this.getUnplacedPieceIndex = __bind(this.getUnplacedPieceIndex, this);
      this.dropPiece = __bind(this.dropPiece, this);
      this.pickUpPiece = __bind(this.pickUpPiece, this);
      this.undrawThreat = __bind(this.undrawThreat, this);
      this.drawThreat = __bind(this.drawThreat, this);
      this.createRectangle = __bind(this.createRectangle, this);
      this.createBoard = __bind(this.createBoard, this);
      this.board = this.createBoard(this.canvas);
      this.calculateThreat();
      this.drawPieces();
      this.unplacedPieces = [];
    }

    ChessGame.prototype.A = 7;

    ChessGame.prototype.B = 6;

    ChessGame.prototype.C = 5;

    ChessGame.prototype.D = 4;

    ChessGame.prototype.E = 3;

    ChessGame.prototype.F = 2;

    ChessGame.prototype.G = 1;

    ChessGame.prototype.H = 0;

    ChessGame.prototype.startSquare = void 0;

    ChessGame.prototype.startX = void 0;

    ChessGame.prototype.startY = void 0;

    ChessGame.prototype.endSquare = void 0;

    ChessGame.prototype.dragLock = false;

    ChessGame.prototype.check = false;

    ChessGame.prototype.canvas = void 0;

    ChessGame.prototype.boardSquares = [];

    ChessGame.prototype.board = void 0;

    ChessGame.prototype.playerColor = void 0;

    ChessGame.prototype.whitesTurn = true;

    ChessGame.prototype.createBoard = function(canvas) {
      var board, col, letter, letters, num, x, y, _i, _j, _k, _l, _m;
      letters = (function() {
        var _i, _results;
        _results = [];
        for (letter = _i = 72; _i >= 65; letter = --_i) {
          _results.push(String.fromCharCode(letter));
        }
        return _results;
      })();
      board = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = letters.length; _i < _len; _i++) {
          letter = letters[_i];
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (num = _j = 1; _j <= 8; num = ++_j) {
              _results1.push(new window.Square("" + letter + num, num, letter));
            }
            return _results1;
          })());
        }
        return _results;
      })();
      for (y = _i = 0; _i <= 7; y = ++_i) {
        for (x = _j = 0; _j <= 7; x = ++_j) {
          board[x][y].x = x;
          board[x][y].y = y;
        }
      }
      for (col = _k = 0; _k <= 7; col = ++_k) {
        board[col][1].piece = new window.Pawn("white", "pawn", true);
        board[col][6].piece = new window.Pawn("black", "pawn", true);
      }
      board[this.A][0].piece = new window.Rook("white", "rook", true);
      board[this.H][0].piece = new window.Rook("white", "rook", true);
      board[this.A][7].piece = new window.Rook("black", "rook", true);
      board[this.H][7].piece = new window.Rook("black", "rook", true);
      board[this.B][0].piece = new window.Knight("white", "knight", true);
      board[this.G][0].piece = new window.Knight("white", "knight", true);
      board[this.B][7].piece = new window.Knight("black", "knight", true);
      board[this.G][7].piece = new window.Knight("black", "knight", true);
      board[this.C][0].piece = new window.Bishop("white", "bishop", true);
      board[this.F][0].piece = new window.Bishop("white", "bishop", true);
      board[this.C][7].piece = new window.Bishop("black", "bishop", true);
      board[this.F][7].piece = new window.Bishop("black", "bishop", true);
      board[this.E][0].piece = new window.King("white", "king", true);
      board[this.E][7].piece = new window.King("black", "king", true);
      board[this.D][0].piece = new window.Queen("white", "queen", true);
      board[this.D][7].piece = new window.Queen("black", "queen", true);
      for (x = _l = 0; _l <= 7; x = ++_l) {
        for (y = _m = 0; _m <= 7; y = ++_m) {
          board[x][y].graphic = this.createRectangle(x * squareSize, y * squareSize, (y + x) % 2 === 0 ? COLORS.light : COLORS.dark);
        }
      }
      return board;
    };

    ChessGame.prototype.createRectangle = function(x, y, color) {
      var rectangle;
      rectangle = this.canvas.display.rectangle({
        x: x,
        y: y,
        width: squareSize,
        height: squareSize,
        fill: color
      });
      this.canvas.addChild(rectangle);
      return rectangle;
    };

    ChessGame.prototype.drawThreat = function(img) {
      if (this.dragLock) {
        return void 0;
      }
      this.setSquareColorForImg(img, COLORS.red);
      return this.canvas.redraw();
    };

    ChessGame.prototype.undrawThreat = function(img) {
      if (this.dragLock) {
        return void 0;
      }
      this.setSquareColorForImg(img);
      return this.canvas.redraw();
    };

    ChessGame.prototype.pickUpPiece = function(displayObj) {
      var piece;
      piece = displayObj.piece;
      if (displayObj.piece == null) {
        console.log("could not find a piece for this display object");
        console.log(displayObj);
        return;
      }
      this.dragLock = true;
      this.resetBoardColor();
      this.startX = displayObj.x;
      this.startY = displayObj.y;
      if (piece.placed) {
        return this.startSquare = this.board[Math.floor(displayObj.x / squareSize)][Math.floor(displayObj.y / squareSize)];
      }
    };

    ChessGame.prototype.dropPiece = function(displayObj, playerColor) {
      var piece, revert,
        _this = this;
      piece = displayObj.piece;
      if (piece == null) {
        console.log("No piece selected");
        this.dragLock = false;
        return;
      }
      revert = function() {
        displayObj.x = _this.startX;
        displayObj.y = _this.startY;
        return _this.dragLock = false;
      };
      if (playerGameNum !== this.gameId) {
        console.log("player is playing on board " + playerGameNum + " and cannot move pieces on board " + this.gameId);
        revert();
        return;
      }
      if (piece.color !== this.playerColor) {
        console.log("Player is " + this.playerColor + ". Can't move " + piece.color + " piece.");
        revert();
        return;
      }
      if (this.playerColor === 'white' && !this.whitesTurn || this.playerColor === 'black' && this.whitesTurn) {
        console.log("" + this.playerColor + " cannot move out of turn");
        revert();
        return;
      }
      this.endSquare = this.board[Math.floor(displayObj.x / squareSize)][Math.floor(displayObj.y / squareSize)];
      if (piece.placed) {
        return piece.move(this.startSquare, this.endSquare, function(isValid) {
          var colorturn;
          if (!isValid || _this.isObstructed(_this.startSquare, _this.endSquare, _this.board)) {
            return revert();
          } else if (_this.check) {
            if (!_this.isCheckRemoved(_this.startSquare, _this.endSquare)) {
              colorturn = _this.whitesTurn ? "white" : "black";
              console.log("" + colorturn + " is in check; must move king or block check");
              alert("" + colorturn + " is in check; must move king or block check");
              return revert();
            } else {
              return _this.moveSuccess(displayObj, _this.startSquare, _this.endSquare, true);
            }
          } else {
            return _this.moveSuccess(displayObj, _this.startSquare, _this.endSquare, true);
          }
        });
      } else if (piece.placed === false) {
        if (this.endSquare.piece != null) {
          console.log("cannot place a piece on an occupied square");
          revert();
        } else {
          return this.dropSuccess(this.getUnplacedPieceIndex(piece.name), this.endSquare, true);
        }
      } else {
        console.log("unhandled piece state");
        console.log(piece);
      }
    };

    ChessGame.prototype.getUnplacedPieceIndex = function(pieceName) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.unplacedPieces.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        console.log("compare: ");
        console.log(this.unplacedPieces[i]);
        console.log(" with ");
        console.log(pieceName);
        if (this.unplacedPieces[i].name === pieceName) {
          return i;
        }
      }
    };

    ChessGame.prototype.drawPieces = function(canvas, board) {
      var img, instance, that, x, y, _i, _results;
      _results = [];
      for (x = _i = 0; _i <= 7; x = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j <= 7; y = ++_j) {
            if (this.board[x][y].piece != null) {
              img = this.canvas.display.image({
                x: x * squareSize + squareSize / 2,
                y: y * squareSize + squareSize / 2,
                origin: {
                  x: "center",
                  y: "center"
                },
                height: squareSize,
                width: squareSize,
                image: this.board[x][y].piece.graphic
              });
              this.board[x][y].piece.displayObject = img;
              this.canvas.addChild(img);
              img.piece = this.board[x][y].piece;
              that = this;
              img.bind("mouseenter", function() {
                return that.drawThreat(this);
              });
              img.bind("mouseleave", function() {
                return that.undrawThreat(this);
              });
              instance = this;
              _results1.push(img.dragAndDrop({
                start: function() {
                  return instance.pickUpPiece(this);
                },
                end: function() {
                  return instance.dropPiece(this);
                }
              }));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ChessGame.prototype.drawUnplacedPieces = function() {
      var img, instance, piece, _i, _len, _ref, _results;
      _ref = this.unplacedPieces;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        piece = _ref[_i];
        img = this.canvas.display.image({
          x: squareSize * 8 + squareSize / 2,
          y: squareSize / 2,
          origin: {
            x: "center",
            y: "center"
          },
          height: squareSize,
          width: squareSize,
          image: piece.graphic
        });
        piece.displayObject = img;
        this.canvas.addChild(img);
        img.piece = piece;
        instance = this;
        _results.push(img.dragAndDrop({
          start: function() {
            return instance.pickUpPiece(this);
          },
          end: function() {
            return instance.dropPiece(this);
          }
        }));
      }
      return _results;
    };

    ChessGame.prototype.resetBoardColor = function() {
      var x, y, _i, _results;
      _results = [];
      for (y = _i = 0; _i <= 7; y = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (x = _j = 0; _j <= 7; x = ++_j) {
            if ((y + x) % 2 === 0) {
              _results1.push(this.board[x][y].graphic.fill = COLORS.light);
            } else {
              _results1.push(this.board[x][y].graphic.fill = COLORS.dark);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ChessGame.prototype.setSquareColorForImg = function(img, color) {
      var piece, sq, square, threatenedSqs, x, y, _i, _len, _results;
      x = Math.floor(img.x / squareSize);
      y = Math.floor(img.y / squareSize);
      square = this.board[x][y];
      piece = square.piece;
      if (piece == null) {
        return;
      }
      threatenedSqs = piece.getThreatenedSquares(this.board, x, y);
      _results = [];
      for (_i = 0, _len = threatenedSqs.length; _i < _len; _i++) {
        sq = threatenedSqs[_i];
        _results.push(sq.graphic.fill = color || ((sq.y + sq.x) % 2 === 0 ? COLORS.light : COLORS.dark));
      }
      return _results;
    };

    ChessGame.prototype.moveSuccess = function(displayObj, startSquare, endSquare, movedBySelf) {
      var capturedPiece;
      if (displayObj == null) {
        console.log("invalid displayObj: " + displayObj);
        return;
      }
      if (movedBySelf) {
        this.sendMove(startSquare, endSquare);
      }
      console.log("" + startSquare.piece.text + " " + startSquare.name + "-" + endSquare.name);
      capturedPiece = endSquare.piece;
      if (capturedPiece != null) {
        capturedPiece.displayObject.remove();
        if (movedBySelf) {
          socket.emit('capturePiece', {
            gameId: this.gameId,
            piece: capturedPiece.name,
            color: capturedPiece.color
          });
        }
      }
      startSquare.piece.square = endSquare;
      endSquare.piece = startSquare.piece;
      startSquare.piece = void 0;
      displayObj.x = (endSquare.x * squareSize) + squareSize / 2;
      displayObj.y = (endSquare.y * squareSize) + squareSize / 2;
      this.dragLock = false;
      this.canvas.redraw();
      return this.toggleTurn();
    };

    ChessGame.prototype.dropSuccess = function(index, endSquare, movedBySelf) {
      var displayObj, piece, that;
      console.log("dropsuccess");
      piece = this.unplacedPieces[index];
      if (movedBySelf) {
        this.sendDrop(index, endSquare);
      }
      this.unplacedPieces.splice(index, 1);
      displayObj = piece.displayObject;
      console.log("dropping " + piece.name + " at " + endSquare.name);
      endSquare.piece = piece;
      piece.square = endSquare;
      piece.placed = true;
      that = this;
      displayObj.bind("mouseenter", function() {
        return that.drawThreat(this);
      });
      displayObj.bind("mouseleave", function() {
        return that.undrawThreat(this);
      });
      displayObj.x = (endSquare.x * squareSize) + squareSize / 2;
      displayObj.y = (endSquare.y * squareSize) + squareSize / 2;
      this.dragLock = false;
      this.calculateThreat();
      this.canvas.redraw();
      return this.toggleTurn();
    };

    ChessGame.prototype.toggleTurn = function() {
      this.whitesTurn = !this.whitesTurn;
      if (this.whitesTurn) {
        $('#turn-label').text("White's turn");
      } else {
        $('#turn-label').text("Black's turn");
      }
      this.calculateThreat();
      this.resetColors();
      return this.check = this.checkForCheck();
    };

    ChessGame.prototype.isCheckRemoved = function() {
      var endSqPiece, newCheck;
      if (!this.check) {
        console.log("player is not in check to begin with!");
        return false;
      }
      endSqPiece = this.endSquare.piece;
      this.startSquare.piece.square = this.endSquare;
      this.endSquare.piece = this.startSquare.piece;
      this.startSquare.piece = void 0;
      this.calculateThreat();
      newCheck = this.checkForCheck();
      this.endSquare.piece.square = this.startSquare;
      this.startSquare.piece = this.endSquare.piece;
      this.endSquare.piece = endSqPiece;
      this.calculateThreat();
      return newCheck === false;
    };

    ChessGame.prototype.checkForCheck = function() {
      var colorTurn, kingSq, piece, x, y, _i, _j, _k, _len, _ref, _ref1;
      kingSq = void 0;
      colorTurn = this.whitesTurn ? "white" : "black";
      for (x = _i = 0; _i <= 7; x = ++_i) {
        for (y = _j = 0; _j <= 7; y = ++_j) {
          if (((_ref = this.board[x][y].piece) != null ? _ref.name : void 0) === ("" + colorTurn + " king")) {
            kingSq = this.board[x][y];
          }
        }
      }
      _ref1 = kingSq.threats;
      for (_k = 0, _len = _ref1.length; _k < _len; _k++) {
        piece = _ref1[_k];
        if (piece.color !== colorTurn) {
          console.log("" + colorTurn + " is in check");
          return true;
        }
      }
      return false;
    };

    ChessGame.prototype.resetColors = function() {
      var x, y, _i, _results;
      _results = [];
      for (x = _i = 0; _i <= 7; x = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j <= 7; y = ++_j) {
            _results1.push(this.setSquareColorForImg(this.board[x][y].graphic));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ChessGame.prototype.calculateThreat = function() {
      var piece, sq, threatenedSquares, x, y, _i, _j, _k, _results;
      for (x = _i = 0; _i <= 7; x = ++_i) {
        for (y = _j = 0; _j <= 7; y = ++_j) {
          this.board[x][y].threats = [];
        }
      }
      _results = [];
      for (x = _k = 0; _k <= 7; x = ++_k) {
        _results.push((function() {
          var _l, _results1;
          _results1 = [];
          for (y = _l = 0; _l <= 7; y = ++_l) {
            piece = this.board[x][y].piece;
            if (piece != null) {
              threatenedSquares = piece.getThreatenedSquares(this.board, x, y);
              _results1.push((function() {
                var _len, _m, _results2;
                _results2 = [];
                for (_m = 0, _len = threatenedSquares.length; _m < _len; _m++) {
                  sq = threatenedSquares[_m];
                  _results2.push(sq.threats.push(piece));
                }
                return _results2;
              })());
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    ChessGame.prototype.sendMove = function(startSquare, endSquare) {
      var moveInfo, pieceName, _ref;
      pieceName = (_ref = startSquare.piece) != null ? _ref.text : void 0;
      if (pieceName == null) {
        console.log("Cannot send move if start square is empty");
        return;
      }
      moveInfo = {
        player: sessionId,
        piece: pieceName,
        startSquare: [startSquare.x, startSquare.y],
        endSquare: [endSquare.x, endSquare.y],
        gameId: this.gameId
      };
      return socket.emit('newMove', moveInfo);
    };

    ChessGame.prototype.sendDrop = function(index, endSquare) {
      var dropInfo, pieceColor, pieceName, _ref, _ref1;
      console.log("send drop");
      console.log("index: " + index);
      console.log("endsquare: " + endSquare.name);
      console.log(this.unplacedPieces);
      pieceName = (_ref = this.unplacedPieces[index]) != null ? _ref.text : void 0;
      pieceColor = (_ref1 = this.unplacedPieces[index]) != null ? _ref1.color : void 0;
      if (pieceName == null) {
        console.log("Error finding piece to drop");
        return;
      }
      dropInfo = {
        player: sessionId,
        piece: "" + pieceColor + " " + pieceName,
        endSquare: [endSquare.x, endSquare.y],
        gameId: this.gameId
      };
      return socket.emit('newDrop', dropInfo);
    };

    ChessGame.prototype.addPieceToGame = function(pieceInfo) {
      var color, colorAndType, piece, pieceName, type;
      console.log("adding piece to game:");
      console.log(pieceInfo);
      pieceName = pieceInfo.piece;
      if (pieceName == null) {
        return;
      }
      colorAndType = pieceName.split(" ");
      if (colorAndType.length !== 2) {
        return;
      }
      color = colorAndType[0];
      type = colorAndType[1];
      if (type === "pawn") {
        piece = new window.Pawn(color, type, false);
      }
      if (type === "rook") {
        piece = new window.Pawn(color, type, false);
      }
      if (type === "knight") {
        piece = new window.Pawn(color, type, false);
      }
      if (type === "bishop") {
        piece = new window.Pawn(color, type, false);
      }
      if (type === "queen") {
        piece = new window.Pawn(color, type, false);
      }
      if (piece == null) {
        return;
      }
      this.unplacedPieces.push(piece);
      return this.drawUnplacedPieces();
    };

    ChessGame.prototype.isObstructed = function(startSquare, endSquare, board) {
      var col, i, j, row, slope, xDist, xRange, yDist, yRange, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _results, _results1;
      if (endSquare.x === startSquare.x) {
        i = Math.min(startSquare.y, endSquare.y) + 1;
        j = Math.max(startSquare.y, endSquare.y) - 1;
        if (j - i < 0) {
          return false;
        }
        for (row = _i = i; i <= j ? _i <= j : _i >= j; row = i <= j ? ++_i : --_i) {
          if (this.board[startSquare.x][row].piece != null) {
            return true;
          }
        }
      }
      if (endSquare.y === startSquare.y) {
        i = Math.min(startSquare.x, endSquare.x) + 1;
        j = Math.max(startSquare.x, endSquare.x) - 1;
        if (j - i < 0) {
          return false;
        }
        for (col = _j = i; i <= j ? _j <= j : _j >= j; col = i <= j ? ++_j : --_j) {
          if (this.board[col][startSquare.y].piece != null) {
            return true;
          }
        }
      }
      xDist = endSquare.x - startSquare.x;
      yDist = endSquare.y - startSquare.y;
      slope = xDist / yDist;
      if (Math.abs(slope) === 1 && Math.abs(xDist) > 1 && Math.abs(yDist) > 1) {
        xRange = (function() {
          _results = [];
          for (var _k = _ref = startSquare.x, _ref1 = endSquare.x; _ref <= _ref1 ? _k <= _ref1 : _k >= _ref1; _ref <= _ref1 ? _k++ : _k--){ _results.push(_k); }
          return _results;
        }).apply(this).slice(1, -1);
        yRange = (function() {
          _results1 = [];
          for (var _l = _ref2 = startSquare.y, _ref3 = endSquare.y; _ref2 <= _ref3 ? _l <= _ref3 : _l >= _ref3; _ref2 <= _ref3 ? _l++ : _l--){ _results1.push(_l); }
          return _results1;
        }).apply(this).slice(1, -1);
        for (i = _m = 0, _ref4 = xRange.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
          if (this.board[xRange[i]][yRange[i]].piece != null) {
            return true;
          }
        }
      }
      return false;
    };

    return ChessGame;

  })();

}).call(this);
