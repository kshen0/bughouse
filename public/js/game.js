// Generated by CoffeeScript 1.6.3
(function() {
  var Board, COLORS, boards, getRoomId, handleConnectResponse, init, playerColor, playerGameNum, serverBaseUrl, sessionId, socket, squareSize,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.Game = window.Game || {};

  serverBaseUrl = document.domain;

  socket = io.connect(serverBaseUrl);

  sessionId = '';

  COLORS = {
    red: "#e74c3c",
    dark: "#34495e",
    light: "#95a5a6",
    green: "#27ae60",
    midnight_blue: "#2c3e50"
  };

  squareSize = 50;

  boards = {
    one: {},
    two: {}
  };

  playerGameNum = 'unknown';

  playerColor = void 0;

  oCanvas.domReady(function() {
    return init();
  });

  getRoomId = function() {
    var url;
    url = document.URL.split("/");
    return url[url.length - 1];
  };

  init = function() {
    var boardNum, canvas, roomId, _i, _len, _ref;
    _ref = ["one", "two"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      boardNum = _ref[_i];
      canvas = oCanvas.create({
        canvas: "#board-" + boardNum,
        background: COLORS.midnight_blue
      });
      canvas.height = 8 * squareSize;
      canvas.width = 12 * squareSize;
      boards[boardNum].canvas = canvas;
    }
    roomId = getRoomId();
    console.log("connected to game " + roomId);
    socket.on('connect', function() {
      sessionId = socket.socket.sessionid;
      console.log("sessionId " + sessionId);
      socket.emit('newUser', {
        id: sessionId,
        name: "player"
      });
      return $.get("/game/player/info/" + sessionId, handleConnectResponse);
    });
    socket.on('newMove', function(moveInfo) {
      var end, endSquare, game, start, startSquare;
      if (moveInfo.player === sessionId) {
        return;
      }
      if (getRoomId() !== moveInfo.roomId) {
        return;
      }
      start = moveInfo.startSquare;
      end = moveInfo.endSquare;
      game = boards[moveInfo.gameId].board;
      startSquare = game.board[start[0]][start[1]];
      endSquare = game.board[end[0]][end[1]];
      return game.moveSuccess(startSquare.piece.displayObject, startSquare, endSquare);
    });
    socket.on('newDrop', function(dropInfo) {
      var end, endSquare, game;
      if (dropInfo.player === sessionId) {
        return;
      }
      end = dropInfo.endSquare;
      game = boards[dropInfo.gameId];
      endSquare = game.board[end[0]][end[1]];
      return game.dropSuccess(game.getUnplacedPieceIndex(dropInfo.piece), endSquare);
    });
    return socket.on('transferPiece', function(pieceInfo) {
      var targetGame;
      targetGame = pieceInfo.gameId === 'one' ? 'two' : 'one';
      return boards[targetGame].board.addPieceToGame(pieceInfo);
    });
  };

  handleConnectResponse = function(resp) {
    var roomId;
    playerColor = resp.color;
    playerGameNum = resp.gameNum;
    $('#player-label').text("You are " + playerColor + " on board " + playerGameNum);
    roomId = getRoomId();
    return $.get("/game/status/" + roomId, function(resp) {
      if (playerGameNum === 'one') {
        boards.one.board = new Board(resp.boards.one, playerColor, boards.one.canvas, "one");
        return boards.two.board = new Board(resp.boards.two, 'spectator', boards.two.canvas, "two");
      } else if (playerGameNum === 'two') {
        boards.one.board = new Board(resp.boards.one, 'spectator', boards.one.canvas, "one");
        return boards.two.board = new Board(resp.boards.two, playerColor, boards.two.canvas, "two");
      }
    });
  };

  Board = (function() {
    var gameOver;

    Board.prototype.A = 7;

    Board.prototype.B = 6;

    Board.prototype.C = 5;

    Board.prototype.D = 4;

    Board.prototype.E = 3;

    Board.prototype.F = 2;

    Board.prototype.G = 1;

    Board.prototype.H = 0;

    Board.prototype.startSquare = void 0;

    Board.prototype.startX = void 0;

    Board.prototype.startY = void 0;

    Board.prototype.endSquare = void 0;

    Board.prototype.dragLock = false;

    Board.prototype.check = false;

    Board.prototype.canvas = void 0;

    Board.prototype.boardSquares = [];

    Board.prototype.board = void 0;

    Board.prototype.playerColor = void 0;

    Board.prototype.whitesTurn = true;

    gameOver = false;

    function Board(boardParams, playerColor, canvas, gameId) {
      this.playerColor = playerColor;
      this.canvas = canvas;
      this.gameId = gameId;
      this.isObstructed = __bind(this.isObstructed, this);
      this.addPieceToGame = __bind(this.addPieceToGame, this);
      this.sendDrop = __bind(this.sendDrop, this);
      this.sendMove = __bind(this.sendMove, this);
      this.calculateThreat = __bind(this.calculateThreat, this);
      this.dropSuccess = __bind(this.dropSuccess, this);
      this.createPiece = __bind(this.createPiece, this);
      this.drawPromoteDialog = __bind(this.drawPromoteDialog, this);
      this.moveSuccess = __bind(this.moveSuccess, this);
      this.resetBoardColor = __bind(this.resetBoardColor, this);
      this.drawUnplacedPieces = __bind(this.drawUnplacedPieces, this);
      this.drawPieces = __bind(this.drawPieces, this);
      this.getUnplacedPieceIndex = __bind(this.getUnplacedPieceIndex, this);
      this.dropPiece = __bind(this.dropPiece, this);
      this.pickUpPiece = __bind(this.pickUpPiece, this);
      this.undrawThreat = __bind(this.undrawThreat, this);
      this.drawThreat = __bind(this.drawThreat, this);
      this.debugPiece = __bind(this.debugPiece, this);
      this.unplacedPieces = [];
      this.createBoard(boardParams);
      this.drawPieces();
      this.drawUnplacedPieces();
      canvas.redraw();
      this.calculateThreat();
    }

    Board.prototype.createBoard = function(boardParams) {
      var boardState, letter, letters, num, pieceParams, turnLabel, type, unplacedPiece, x, y, _i, _j, _len, _ref, _results;
      boardState = boardParams.board;
      console.log(boardParams);
      this.whitesTurn = boardParams.whitesTurn;
      turnLabel = this.whitesTurn ? "white's turn" : "black's turn";
      $("#turn-label-" + this.gameId).html("Board " + this.gameId + " - " + turnLabel);
      _ref = boardParams.unplacedPieces;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unplacedPiece = _ref[_i];
        type = unplacedPiece.text;
        if (type === "pawn") {
          console.log("pawn unplaced");
          this.unplacedPieces.push(new window.Pawn(unplacedPiece));
        } else if (type === "knight") {
          this.unplacedPieces.push(new window.Knight(unplacedPiece));
        } else if (type === "bishop") {
          this.unplacedPieces.push(new window.Bishop(unplacedPiece));
        } else if (type === "rook") {
          this.unplacedPieces.push(new window.Rook(unplacedPiece));
        } else if (type === "king") {
          this.unplacedPieces.push(new window.King(unplacedPiece));
        } else if (type === "queen") {
          this.unplacedPieces.push(new window.Queen(unplacedPiece));
        }
      }
      letters = (function() {
        var _j, _results;
        _results = [];
        for (letter = _j = 72; _j >= 65; letter = --_j) {
          _results.push(String.fromCharCode(letter));
        }
        return _results;
      })();
      this.board = (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = letters.length; _j < _len1; _j++) {
          letter = letters[_j];
          _results.push((function() {
            var _k, _results1;
            _results1 = [];
            for (num = _k = 1; _k <= 8; num = ++_k) {
              _results1.push(new window.Square("" + letter + num, num, letter));
            }
            return _results1;
          })());
        }
        return _results;
      })();
      _results = [];
      for (y = _j = 0; _j <= 7; y = ++_j) {
        _results.push((function() {
          var _k, _results1;
          _results1 = [];
          for (x = _k = 0; _k <= 7; x = ++_k) {
            this.board[x][y].x = x;
            this.board[x][y].y = y;
            this.board[x][y].graphic = this.createRectangle(x * squareSize, y * squareSize, (y + x) % 2 === 0 ? COLORS.light : COLORS.dark);
            this.board[x][y].threat = boardState[x][y].threat;
            this.board[x][y].threats = boardState[x][y].threats;
            pieceParams = boardState[x][y].piece;
            if (pieceParams != null) {
              type = pieceParams.text;
              if (type === "pawn") {
                _results1.push(this.board[x][y].piece = new window.Pawn(pieceParams));
              } else if (type === "knight") {
                _results1.push(this.board[x][y].piece = new window.Knight(pieceParams));
              } else if (type === "bishop") {
                _results1.push(this.board[x][y].piece = new window.Bishop(pieceParams));
              } else if (type === "rook") {
                _results1.push(this.board[x][y].piece = new window.Rook(pieceParams));
              } else if (type === "king") {
                _results1.push(this.board[x][y].piece = new window.King(pieceParams));
              } else if (type === "queen") {
                _results1.push(this.board[x][y].piece = new window.Queen(pieceParams));
              } else {
                _results1.push(void 0);
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.createRectangle = function(x, y, color) {
      var rectangle;
      rectangle = this.canvas.display.rectangle({
        x: x,
        y: y,
        width: squareSize,
        height: squareSize,
        fill: color
      });
      this.canvas.addChild(rectangle);
      return rectangle;
    };

    Board.prototype.debugPiece = function(img) {
      var html, k, piece, pieceInfo, square, v, x, y, _ref, _ref1, _ref2;
      x = Math.floor(img.x / squareSize);
      y = Math.floor(img.y / squareSize);
      square = this.board[x][y];
      piece = square.piece;
      if (piece == null) {
        return;
      }
      pieceInfo = {
        name: piece.name,
        computedSquare: square.name,
        computedSquareCoords: "" + square.x + ", " + square.y,
        linkedSquare: (_ref = piece.square) != null ? _ref.name : void 0,
        linkedSquareCoords: "" + ((_ref1 = piece.square) != null ? _ref1.x : void 0) + ", " + ((_ref2 = piece.square) != null ? _ref2.y : void 0)
      };
      html = "<ul>";
      for (k in pieceInfo) {
        v = pieceInfo[k];
        html += "<li>" + k + ": " + v + "</li>";
      }
      html += "</ul>";
      return $("#debug").html(html);
    };

    Board.prototype.drawThreat = function(img) {
      if (this.dragLock) {
        return void 0;
      }
      this.setSquareColorForImg(img, COLORS.red);
      return this.canvas.redraw();
    };

    Board.prototype.undrawThreat = function(img) {
      if (this.dragLock) {
        return void 0;
      }
      this.setSquareColorForImg(img);
      return this.canvas.redraw();
    };

    Board.prototype.pickUpPiece = function(displayObj) {
      var piece;
      piece = displayObj.piece;
      if (displayObj.piece == null) {
        console.log("could not find a piece for this display object");
        console.log(displayObj);
        return;
      }
      this.dragLock = true;
      this.resetBoardColor();
      this.startX = displayObj.x;
      this.startY = displayObj.y;
      if (piece.placed) {
        return this.startSquare = this.board[Math.floor(displayObj.x / squareSize)][Math.floor(displayObj.y / squareSize)];
      }
    };

    Board.prototype.dropPiece = function(displayObj, playerColor) {
      var colorturn, otherColor, piece, revert,
        _this = this;
      piece = displayObj.piece;
      if (piece == null) {
        console.log("No piece selected");
        this.dragLock = false;
        return;
      }
      revert = function() {
        displayObj.x = _this.startX;
        displayObj.y = _this.startY;
        return _this.dragLock = false;
      };
      if (this.gameOver) {
        revert();
        return;
      }
      if (playerGameNum !== this.gameId) {
        console.log("player is playing on board " + playerGameNum + " and cannot move pieces on board " + this.gameId);
        revert();
        return;
      }
      if (piece.color !== this.playerColor) {
        console.log("Player is " + this.playerColor + ". Can't move " + piece.color + " piece.");
        revert();
        return;
      }
      if (this.playerColor === 'white' && !this.whitesTurn || this.playerColor === 'black' && this.whitesTurn) {
        console.log("" + this.playerColor + " cannot move out of turn");
        revert();
        return;
      }
      this.endSquare = this.board[Math.floor(displayObj.x / squareSize)][Math.floor(displayObj.y / squareSize)];
      colorturn = this.whitesTurn ? "white" : "black";
      otherColor = this.whitesTurn ? "black" : "white";
      if (piece.placed) {
        return piece.move(this.startSquare, this.endSquare, function(isValid) {
          if (!isValid || _this.isObstructed(_this.startSquare, _this.endSquare, _this.board)) {
            return revert();
          } else if (_this.check) {
            if (!_this.isCheckRemoved(_this.startSquare, _this.endSquare)) {
              console.log("" + colorturn + " is in check; must move king or block check");
              return revert();
            } else {
              return _this.moveSuccess(displayObj, _this.startSquare, _this.endSquare, true);
            }
          } else {
            return _this.moveSuccess(displayObj, _this.startSquare, _this.endSquare, true);
          }
        });
      } else if (piece.placed === false) {
        if (this.endSquare.piece != null) {
          console.log("cannot place a piece on an occupied square");
          revert();
        } else {
          console.log(this);
          return this.dropSuccess(this.getUnplacedPieceIndex(piece.name), this.endSquare, true);
        }
      } else {
        console.log("unhandled piece state");
        console.log(piece);
      }
    };

    Board.prototype.getUnplacedPieceIndex = function(pieceName) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.unplacedPieces.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        console.log("compare: ");
        console.log(this.unplacedPieces[i]);
        console.log(" with ");
        console.log(pieceName);
        if (this.unplacedPieces[i].name === pieceName) {
          return i;
        }
      }
    };

    Board.prototype.drawPieces = function(canvas, board) {
      var img, that, x, y, _i, _j, _k, _ref, _results;
      for (x = _i = 0; _i <= 7; x = ++_i) {
        for (y = _j = 0; _j <= 7; y = ++_j) {
          if (((_ref = this.board[x][y].piece) != null ? _ref.displayObject : void 0) != null) {
            this.board[x][y].piece.displayObject.remove();
          }
        }
      }
      _results = [];
      for (x = _k = 0; _k <= 7; x = ++_k) {
        _results.push((function() {
          var _l, _results1;
          _results1 = [];
          for (y = _l = 0; _l <= 7; y = ++_l) {
            if (this.board[x][y].piece != null) {
              img = this.canvas.display.image({
                x: x * squareSize + squareSize / 2,
                y: y * squareSize + squareSize / 2,
                origin: {
                  x: "center",
                  y: "center"
                },
                height: squareSize,
                width: squareSize,
                image: this.board[x][y].piece.graphic
              });
              this.board[x][y].piece.displayObject = img;
              this.canvas.addChild(img);
              img.piece = this.board[x][y].piece;
              that = this;
              img.bind("mouseenter", function() {
                return that.drawThreat(this);
              });
              img.bind("mouseleave", function() {
                return that.undrawThreat(this);
              });
              _results1.push(img.dragAndDrop({
                start: function() {
                  return that.pickUpPiece(this);
                },
                end: function() {
                  return that.dropPiece(this);
                }
              }));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.drawUnplacedPieces = function() {
      var i, img, instance, piece, _i, _len, _ref, _results;
      _ref = this.unplacedPieces;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        piece = _ref[i];
        img = this.canvas.display.image({
          x: squareSize * 8 + (i % 4) * squareSize + squareSize / 2,
          y: Math.floor(i / 4) * squareSize + (squareSize / 2),
          origin: {
            x: "center",
            y: "center"
          },
          height: squareSize,
          width: squareSize,
          image: piece.graphic
        });
        piece.displayObject = img;
        this.canvas.addChild(img);
        img.piece = piece;
        instance = this;
        _results.push(img.dragAndDrop({
          start: function() {
            return instance.pickUpPiece(this);
          },
          end: function() {
            return instance.dropPiece(this);
          }
        }));
      }
      return _results;
    };

    Board.prototype.resetBoardColor = function() {
      var x, y, _i, _results;
      _results = [];
      for (y = _i = 0; _i <= 7; y = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (x = _j = 0; _j <= 7; x = ++_j) {
            if ((y + x) % 2 === 0) {
              _results1.push(this.board[x][y].graphic.fill = COLORS.light);
            } else {
              _results1.push(this.board[x][y].graphic.fill = COLORS.dark);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.setSquareColorForImg = function(img, color) {
      var piece, sq, square, threatenedSqs, x, y, _i, _len, _results;
      x = Math.floor(img.x / squareSize);
      y = Math.floor(img.y / squareSize);
      square = this.board[x][y];
      piece = square.piece;
      if (piece == null) {
        return;
      }
      threatenedSqs = piece.getThreatenedSquares(this.board, x, y);
      _results = [];
      for (_i = 0, _len = threatenedSqs.length; _i < _len; _i++) {
        sq = threatenedSqs[_i];
        _results.push(sq != null ? sq.graphic.fill = color || ((sq.y + sq.x) % 2 === 0 ? COLORS.light : COLORS.dark) : void 0);
      }
      return _results;
    };

    Board.prototype.moveSuccess = function(displayObj, startSquare, endSquare, movedBySelf) {
      var capturedPiece;
      if (displayObj == null) {
        console.log("invalid displayObj: " + displayObj);
        return;
      }
      if (movedBySelf) {
        this.sendMove(startSquare, endSquare);
      }
      console.log("" + startSquare.piece.text + " " + startSquare.name + "-" + endSquare.name);
      capturedPiece = endSquare.piece;
      if (capturedPiece != null) {
        capturedPiece.displayObject.remove();
        if (movedBySelf) {
          socket.emit('capturePiece', {
            roomId: getRoomId(),
            gameId: this.gameId,
            piece: capturedPiece.name,
            color: capturedPiece.color,
            text: capturedPiece.text,
            placed: false
          });
        }
      }
      startSquare.piece.square = endSquare;
      endSquare.piece = startSquare.piece;
      startSquare.piece = void 0;
      displayObj.x = (endSquare.x * squareSize) + squareSize / 2;
      displayObj.y = (endSquare.y * squareSize) + squareSize / 2;
      if (movedBySelf && endSquare.piece.text === 'pawn') {
        if (endSquare.piece.color === 'white' && endSquare.y === 7) {
          console.log('promote white pawn');
          this.drawPromoteDialog('white', endSquare);
        }
        if (endSquare.piece.color === 'black' && endSquare.y === 0) {
          console.log('promote black pawn');
        }
      }
      this.dragLock = false;
      this.canvas.redraw();
      return this.toggleTurn();
    };

    Board.prototype.drawPromoteDialog = function(color, endSquare) {
      var height, i, pieceName, pieces, rectangle, sprite, that, width, _i, _len;
      width = 4 * squareSize;
      height = 1.5 * squareSize;
      rectangle = this.canvas.display.rectangle({
        x: squareSize * 4 - width / 2,
        y: squareSize * 4 - height / 2,
        width: width,
        height: height,
        fill: COLORS.green
      });
      pieces = ['knight', 'bishop', 'rook', 'queen'];
      for (i = _i = 0, _len = pieces.length; _i < _len; i = ++_i) {
        pieceName = pieces[i];
        sprite = this.canvas.display.image({
          x: squareSize * i,
          y: squareSize / 4,
          origin: {
            x: "left",
            y: "left"
          },
          height: squareSize,
          width: squareSize,
          image: "img/" + pieceName + "_" + color + ".png"
        });
        that = this;
        console.log("bind " + pieceName);
        sprite.bind("click", function() {
          return that.createPiece(this, color, endSquare, rectangle);
        });
        rectangle.addChild(sprite);
      }
      return this.canvas.addChild(rectangle);
    };

    Board.prototype.createPiece = function(eventInfo, color, endSquare, picker) {
      var filename, _ref;
      filename = (_ref = eventInfo.img) != null ? _ref.src : void 0;
      if (filename == null) {
        console.log("no imagename found in createPiece");
        return;
      }
      if (endSquare.piece != null) {
        endSquare.piece.displayObject.remove();
      }
      if (filename.indexOf('knight') > -1) {
        endSquare.piece = new window.Knight(color, "knight", true);
      } else if (filename.indexOf('bishop') > -1) {
        endSquare.piece = new window.Bishop(color, "bishop", true);
      } else if (filename.indexOf('rook') > -1) {
        endSquare.piece = new window.Rook(color, "rook", true);
      } else if (filename.indexOf('queen') > -1) {
        endSquare.piece = new window.Queen(color, "queen", true);
      }
      picker.remove();
      this.drawPieces();
      return this.canvas.redraw();
    };

    Board.prototype.dropSuccess = function(index, endSquare, movedBySelf) {
      var displayObj, piece, that;
      console.log("dropsuccess");
      piece = this.unplacedPieces[index];
      if (movedBySelf) {
        this.sendDrop(index, endSquare);
      }
      this.unplacedPieces.splice(index, 1);
      displayObj = piece.displayObject;
      console.log("dropping " + piece.name + " at " + endSquare.name);
      endSquare.piece = piece;
      piece.square = endSquare;
      piece.placed = true;
      that = this;
      displayObj.bind("mouseenter", function() {
        return that.drawThreat(this);
      });
      displayObj.bind("mouseleave", function() {
        return that.undrawThreat(this);
      });
      displayObj.x = (endSquare.x * squareSize) + squareSize / 2;
      displayObj.y = (endSquare.y * squareSize) + squareSize / 2;
      this.dragLock = false;
      this.calculateThreat();
      this.canvas.redraw();
      return this.toggleTurn();
    };

    Board.prototype.toggleTurn = function() {
      var turnLabel;
      this.whitesTurn = !this.whitesTurn;
      turnLabel = this.whitesTurn ? "white's turn" : "black's turn";
      $("#turn-label-" + this.gameId).html("Board " + this.gameId + " - " + turnLabel);
      this.calculateThreat();
      this.resetColors();
      this.check = this.checkForCheck();
      return this.checkForCheckmate();
    };

    Board.prototype.isCheckRemoved = function(startSquare, endSquare) {
      var endSqPiece, newCheck, _ref, _ref1;
      if (!this.check) {
        console.log("player is not in check to begin with!");
        return false;
      }
      if (((_ref = endSquare.piece) != null ? _ref.color : void 0) === ((_ref1 = startSquare.piece) != null ? _ref1.color : void 0)) {
        return false;
      }
      /*
      endSqPiece = @endSquare.piece
      @startSquare.piece.square = @endSquare
      @endSquare.piece = @startSquare.piece
      @startSquare.piece = undefined
      @calculateThreat()
      newCheck = @checkForCheck()
      
      # reset from temporary position
      @endSquare.piece.square = @startSquare
      @startSquare.piece = @endSquare.piece
      @endSquare.piece = endSqPiece
      @calculateThreat()
      
      return newCheck is false
      
      # temporarily change board to assess check
      */

      endSqPiece = endSquare.piece;
      startSquare.piece.square = endSquare;
      endSquare.piece = startSquare.piece;
      startSquare.piece = void 0;
      this.calculateThreat();
      newCheck = this.checkForCheck();
      endSquare.piece.square = startSquare;
      startSquare.piece = endSquare.piece;
      endSquare.piece = endSqPiece;
      this.calculateThreat();
      return newCheck === false;
    };

    Board.prototype.checkForCheckGivenColor = function(colorTurn) {
      var kingSq, piece, x, y, _i, _j, _k, _len, _ref, _ref1;
      kingSq = void 0;
      for (x = _i = 0; _i <= 7; x = ++_i) {
        for (y = _j = 0; _j <= 7; y = ++_j) {
          if (((_ref = this.board[x][y].piece) != null ? _ref.name : void 0) === ("" + colorTurn + " king")) {
            kingSq = this.board[x][y];
          }
        }
      }
      /*
      console.log 'kingsq'
      console.log kingSq
      console.log 'board[3][7]'
      console.log @board[3][7]
      */

      _ref1 = kingSq.threats;
      for (_k = 0, _len = _ref1.length; _k < _len; _k++) {
        piece = _ref1[_k];
        if (piece.color !== colorTurn) {
          return true;
        }
      }
      return false;
    };

    Board.prototype.checkForCheck = function() {
      var colorTurn;
      colorTurn = this.whitesTurn ? "white" : "black";
      return this.checkForCheckGivenColor(colorTurn);
    };

    Board.prototype.checkForCheckmate = function() {
      var color, piece, team, x, y, _i, _j;
      if (!this.check) {
        return false;
      }
      color = this.whitesTurn ? 'white' : 'black';
      for (x = _i = 0; _i <= 7; x = ++_i) {
        for (y = _j = 0; _j <= 7; y = ++_j) {
          piece = this.board[x][y].piece;
          if (!((piece != null) && piece.color === color)) {
            continue;
          }
          if (this.pieceCanStopCheck(piece, this.board[x][y])) {
            console.log("" + piece.name + " at " + this.board[x][y].name + " can stop check");
            return false;
          }
        }
      }
      this.gameOver = true;
      if (this.gameId === 'one' && color === 'black' || this.gamId === 'two' && color === 'white') {
        team = 1;
      } else {
        team = 2;
      }
      /*
      $("#modal").html "<h3>Game over! Team #{team} wins!"
      $("modal").toggle()
      */

      alert("Game over! Team " + team + " wins!");
      return true;
    };

    Board.prototype.pieceCanStopCheck = function(piece, startSquare) {
      var endSquare, i, threatenedSqs, _i, _len;
      threatenedSqs = piece.getThreatenedSquares(this.board, startSquare.x, startSquare.y);
      for (i = _i = 0, _len = threatenedSqs.length; _i < _len; i = ++_i) {
        endSquare = threatenedSqs[i];
        if (this.isCheckRemoved(startSquare, endSquare)) {
          console.log("" + startSquare.name + " - " + endSquare.name + " will block check");
          return true;
        }
      }
      return false;
    };

    Board.prototype.resetColors = function() {
      var x, y, _i, _results;
      _results = [];
      for (x = _i = 0; _i <= 7; x = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j <= 7; y = ++_j) {
            _results1.push(this.setSquareColorForImg(this.board[x][y].graphic));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.calculateThreat = function() {
      var piece, sq, threatenedSquares, x, y, _i, _j, _k, _results;
      for (x = _i = 0; _i <= 7; x = ++_i) {
        for (y = _j = 0; _j <= 7; y = ++_j) {
          this.board[x][y].threats = [];
        }
      }
      _results = [];
      for (x = _k = 0; _k <= 7; x = ++_k) {
        _results.push((function() {
          var _l, _results1;
          _results1 = [];
          for (y = _l = 0; _l <= 7; y = ++_l) {
            piece = this.board[x][y].piece;
            if (piece != null) {
              threatenedSquares = piece.getThreatenedSquares(this.board, x, y);
              _results1.push((function() {
                var _len, _m, _results2;
                _results2 = [];
                for (_m = 0, _len = threatenedSquares.length; _m < _len; _m++) {
                  sq = threatenedSquares[_m];
                  _results2.push(sq.threats.push(piece));
                }
                return _results2;
              })());
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.sendMove = function(startSquare, endSquare) {
      var moveInfo, pieceName, roomId, _ref;
      roomId = getRoomId();
      pieceName = (_ref = startSquare.piece) != null ? _ref.text : void 0;
      if (pieceName == null) {
        console.log("Cannot send move if start square is empty");
        return;
      }
      moveInfo = {
        roomId: roomId,
        player: sessionId,
        piece: pieceName,
        startSquare: [startSquare.x, startSquare.y],
        endSquare: [endSquare.x, endSquare.y],
        gameId: this.gameId
      };
      return socket.emit('newMove', moveInfo);
    };

    Board.prototype.sendDrop = function(index, endSquare) {
      var dropInfo, pieceColor, pieceName, _ref, _ref1;
      console.log("send drop");
      console.log("index: " + index);
      console.log("endsquare: " + endSquare.name);
      console.log(this.unplacedPieces);
      pieceName = (_ref = this.unplacedPieces[index]) != null ? _ref.text : void 0;
      pieceColor = (_ref1 = this.unplacedPieces[index]) != null ? _ref1.color : void 0;
      if (pieceName == null) {
        console.log("Error finding piece to drop");
        return;
      }
      dropInfo = {
        player: sessionId,
        piece: "" + pieceColor + " " + pieceName,
        endSquare: [endSquare.x, endSquare.y],
        gameId: this.gameId,
        roomId: getRoomId()
      };
      return socket.emit('newDrop', dropInfo);
    };

    Board.prototype.addPieceToGame = function(pieceInfo) {
      var color, colorAndType, piece, pieceName, pieceParams, type;
      pieceName = pieceInfo.piece;
      if (pieceName == null) {
        return;
      }
      colorAndType = pieceName.split(" ");
      if (colorAndType.length !== 2) {
        return;
      }
      color = colorAndType[0];
      type = colorAndType[1];
      pieceParams = {
        color: color,
        text: type,
        placed: false
      };
      if (type === "pawn") {
        piece = new window.Pawn(pieceParams);
      }
      if (type === "rook") {
        piece = new window.Pawn(pieceParams);
      }
      if (type === "knight") {
        piece = new window.Pawn(pieceParams);
      }
      if (type === "bishop") {
        piece = new window.Pawn(pieceParams);
      }
      if (type === "queen") {
        piece = new window.Pawn(pieceParams);
      }
      if (piece == null) {
        return;
      }
      this.unplacedPieces.push(piece);
      return this.drawUnplacedPieces();
    };

    Board.prototype.isObstructed = function(startSquare, endSquare, board) {
      var col, i, j, row, slope, xDist, xRange, yDist, yRange, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3, _ref4, _results, _results1;
      if (endSquare.x === startSquare.x) {
        i = Math.min(startSquare.y, endSquare.y) + 1;
        j = Math.max(startSquare.y, endSquare.y) - 1;
        if (j - i < 0) {
          return false;
        }
        for (row = _i = i; i <= j ? _i <= j : _i >= j; row = i <= j ? ++_i : --_i) {
          if (this.board[startSquare.x][row].piece != null) {
            return true;
          }
        }
      }
      if (endSquare.y === startSquare.y) {
        i = Math.min(startSquare.x, endSquare.x) + 1;
        j = Math.max(startSquare.x, endSquare.x) - 1;
        if (j - i < 0) {
          return false;
        }
        for (col = _j = i; i <= j ? _j <= j : _j >= j; col = i <= j ? ++_j : --_j) {
          if (this.board[col][startSquare.y].piece != null) {
            return true;
          }
        }
      }
      xDist = endSquare.x - startSquare.x;
      yDist = endSquare.y - startSquare.y;
      slope = xDist / yDist;
      if (Math.abs(slope) === 1 && Math.abs(xDist) > 1 && Math.abs(yDist) > 1) {
        xRange = (function() {
          _results = [];
          for (var _k = _ref = startSquare.x, _ref1 = endSquare.x; _ref <= _ref1 ? _k <= _ref1 : _k >= _ref1; _ref <= _ref1 ? _k++ : _k--){ _results.push(_k); }
          return _results;
        }).apply(this).slice(1, -1);
        yRange = (function() {
          _results1 = [];
          for (var _l = _ref2 = startSquare.y, _ref3 = endSquare.y; _ref2 <= _ref3 ? _l <= _ref3 : _l >= _ref3; _ref2 <= _ref3 ? _l++ : _l--){ _results1.push(_l); }
          return _results1;
        }).apply(this).slice(1, -1);
        for (i = _m = 0, _ref4 = xRange.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
          if (this.board[xRange[i]][yRange[i]].piece != null) {
            return true;
          }
        }
      }
      return false;
    };

    return Board;

  })();

}).call(this);
